<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASPD Forum ‚Äî Thread</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>

  <!-- Noise Overlay -->
  <div class="noise"></div>

  <!-- Thread Layout -->
  <div class="thread-container" data-page="thread" data-signal-id="">

    <!-- Header -->
    <header class="thread-header" data-component="thread-header">
      <div class="thread-header-left">
        <a href="room.html" class="thread-back" data-bind="back-link">‚Üê INDEX</a>
        <span class="thread-divider">/</span>
        <span class="thread-room" data-bind="room-name">NODE.000</span>
      </div>
      <div class="header-right">
        <span class="thread-entry-count" data-bind="entry-count"><span id="entry-count">0</span> RECORDS</span>
        <a href="#" class="header-notifications" id="notif-bell" title="Notifications">
          <span class="notif-icon">[!]</span>
          <span class="notif-badge" id="notif-badge" style="display: none;">0</span>
        </a>
        <a href="profile.html" class="header-profile">PROFILE</a>
        <a href="messages.html" class="header-messages">MSG</a>
        <a href="#" class="header-exit" data-action="logout">EXIT</a>
      </div>
    </header>

    <!-- Thread Title -->
    <div class="thread-title-bar">
      <h1 class="thread-title" data-bind="thread-title">Loading...</h1>
      <span class="thread-status-badges" id="thread-badges"></span>
      <button class="subscribe-btn" id="subscribe-btn" title="Subscribe to thread">[WATCH]</button>
      <button class="bookmark-btn" id="bookmark-btn" title="Bookmark this thread">[SAVE]</button>
      <span class="thread-slow-mode" id="slow-mode-indicator" style="display: none;"></span>
      <!-- Admin Controls -->
      <div class="thread-admin-controls" id="thread-admin-controls" style="display: none;">
        <button class="admin-btn" id="pin-btn" title="Pin/Unpin thread">[PIN]</button>
        <button class="admin-btn" id="lock-btn" title="Lock/Unlock thread">[LOCK]</button>
      </div>
    </div>

    <!-- Filter Bar -->
    <div class="filter-bar">
      <input type="text" id="search-input" class="filter-input" placeholder="SEARCH ENTRIES...">
      <div class="sort-controls">
        <button class="sort-btn active" data-sort="default">DEFAULT</button>
        <button class="sort-btn" data-sort="newest">NEWEST</button>
        <button class="sort-btn" data-sort="oldest">OLDEST</button>
      </div>
    </div>

    <!-- Poll Container (if thread has a poll) -->
    <div class="poll-container" id="poll-container" style="display: none;">
      <div class="poll-question" id="poll-question"></div>
      <div class="poll-meta" id="poll-meta"></div>
      <div class="poll-options" id="poll-options"></div>
      <button class="poll-vote-btn" id="poll-vote-btn" style="display: none;">VOTE</button>
      <div class="poll-total" id="poll-total"></div>
    </div>

    <!-- Entry List - Container for dynamic entries -->
    <main class="entry-list" id="entries-container" data-container="entries">
      <!-- PLACEHOLDER: Entry elements will be injected here by JS -->
    </main>

    <!-- Pagination -->
    <div id="pagination-container"></div>

    <!-- Reply Form -->
    <div class="reply-form-container">
      <form id="reply-form" class="reply-form">
        <textarea id="reply-content" class="reply-textarea" placeholder="ENTER YOUR RESPONSE..." rows="3" required></textarea>
        <button type="submit" class="reply-submit">TRANSMIT</button>
      </form>
    </div>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="back-to-top" title="Back to top">‚Üë TOP</button>

    <!-- Footer -->
    <footer class="thread-footer" data-component="thread-footer">
      <span data-bind="signal-id">SIG.000</span>
      <span>RECORD VIEW</span>
      <span data-bind="connection-status">CONN.ACTIVE</span>
    </footer>

  </div>

  <script src="js/auth-state.js"></script>
  <script src="js/notify.js"></script>
  <script src="js/notifications.js"></script>
  <script src="js/avatar-renderer.js"></script>
  <script src="js/ui-components.js"></script>
  <script src="js/data-loader.js"></script>
  <script>
    (function() {
      'use strict';

      Notify.checkUrlNotify();

      if (!AuthState.gateProtected()) return;

      var entriesContainer = document.getElementById('entries-container');
      var paginationContainer = document.getElementById('pagination-container');
      var entryCountEl = document.getElementById('entry-count');
      var slowModeIndicator = document.getElementById('slow-mode-indicator');
      var threadContainer = document.querySelector('[data-page="thread"]');
      var threadTitleEl = document.querySelector('[data-bind="thread-title"]');
      var roomNameEl = document.querySelector('[data-bind="room-name"]');
      var signalIdEl = document.querySelector('[data-bind="signal-id"]');
      var backLinkEl = document.querySelector('[data-bind="back-link"]');
      var searchInput = document.getElementById('search-input');
      var sortBtns = document.querySelectorAll('.sort-btn');

      var allEntries = [];
      var allAvatarConfigs = {};
      var currentSort = 'default';
      var currentSearch = '';
      var currentPage = 1;
      var currentPagination = null;
      var currentSignalId = null;
      
      // Get current user ID from JWT token
      var currentUserId = null;
      try {
        var token = AuthState.getToken();
        if (token) {
          var payload = JSON.parse(atob(token.split('.')[1]));
          currentUserId = payload.userId;
        }
      } catch (e) {}
      var currentPagination = null;
      var currentSignalId = null;

      function getSignalIdFromUrl() {
        var params = new URLSearchParams(window.location.search);
        return params.get('id');
      }

      function updateSlowModeIndicator(interval) {
        if (interval && interval > 0) {
          slowModeIndicator.textContent = 'SLOW MODE: ' + interval + 's';
          slowModeIndicator.style.display = 'inline';
        } else {
          slowModeIndicator.style.display = 'none';
        }
      }

      function updateSignalMeta(signalMeta) {
        if (!signalMeta) return;
        var signalId = signalMeta.id || '';
        var signalIndex = signalMeta.signalIndex || 'SIG.000';
        var roomId = signalMeta.roomId || '';
        threadContainer.setAttribute('data-signal-id', signalId);
        threadTitleEl.textContent = signalMeta.title || 'Untitled';
        signalIdEl.textContent = signalIndex;
        if (roomId) {
          backLinkEl.href = 'room.html?id=' + roomId;
        }
        document.title = 'ASPD Forum ‚Äî ' + (signalMeta.title || 'Thread');
        updateSlowModeIndicator(signalMeta.slowModeInterval);
        updateThreadBadges(signalMeta);
        updateAdminControls(signalMeta);
      }

      function updateThreadBadges(threadData) {
        var badgesEl = document.getElementById('thread-badges');
        var badges = [];
        if (threadData.isPinned) badges.push('<span class="thread-badge pinned">üìå PINNED</span>');
        if (threadData.isLocked) badges.push('<span class="thread-badge locked">üîí LOCKED</span>');
        badgesEl.innerHTML = badges.join(' ');
      }

      var currentThreadData = null;

      function updateAdminControls(threadData) {
        currentThreadData = threadData;
        if (!AuthState.isAdmin()) return;
        
        var adminControls = document.getElementById('thread-admin-controls');
        var pinBtn = document.getElementById('pin-btn');
        var lockBtn = document.getElementById('lock-btn');
        
        adminControls.style.display = 'flex';
        pinBtn.textContent = threadData.isPinned ? '[UNPIN]' : '[PIN]';
        lockBtn.textContent = threadData.isLocked ? '[UNLOCK]' : '[LOCK]';
      }

      /**
       * Render entries to the list
       * @param {Array} entries - Array of entry objects
       * @param {Object} avatarConfigs - Map of userId to avatar config (from backend)
       * @param {Object} pagination - Pagination info
       */
      function renderEntries(entries, avatarConfigs, pagination) {
        avatarConfigs = avatarConfigs || {};
        if (!entries || !entries.length) {
          entriesContainer.innerHTML = '<div class="empty-state" data-empty="entries">NO RECORDS AVAILABLE</div>';
          entryCountEl.textContent = '0';
          paginationContainer.innerHTML = '';
          return;
        }
        entriesContainer.innerHTML = entries.map(function(entry) {
          return UIComponents.entryElement(entry, currentUserId);
        }).join('');
        entryCountEl.textContent = pagination ? pagination.total : entries.length;

        // Render pagination
        paginationContainer.innerHTML = UIComponents.paginationControls(pagination);
        
        // Bind pagination events
        paginationContainer.querySelectorAll('.pagination-btn:not(.pagination-go-btn)').forEach(function(btn) {
          btn.addEventListener('click', function() {
            if (btn.disabled) return;
            currentPage = parseInt(btn.dataset.page);
            fetchThread(currentSignalId, currentPage);
          });
        });
        
        // Bind pagination jump events
        var jumpInput = paginationContainer.querySelector('.pagination-jump-input');
        var goBtn = paginationContainer.querySelector('.pagination-go-btn');
        if (jumpInput && goBtn) {
          goBtn.addEventListener('click', function() {
            var pageNum = parseInt(jumpInput.value);
            if (pageNum >= 1 && pageNum <= pagination.totalPages) {
              currentPage = pageNum;
              fetchThread(currentSignalId, currentPage);
            }
          });
          jumpInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              goBtn.click();
            }
          });
        }

        // Bind edit button events
        entriesContainer.querySelectorAll('.entry-edit-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            var entryEl = btn.closest('.entry');
            var content = entryEl.querySelector('.entry-content p').textContent;
            showEditModal(entryId, content);
          });
        });

        // Bind delete button events
        entriesContainer.querySelectorAll('.entry-delete-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            showDeleteConfirm(entryId);
          });
        });

        // Bind quote button events
        entriesContainer.querySelectorAll('.entry-quote-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryEl = btn.closest('.entry');
            var alias = btn.dataset.alias;
            var content = entryEl.querySelector('.entry-content p').textContent;
            quoteEntry(alias, content);
          });
        });

        // Bind report button events
        entriesContainer.querySelectorAll('.entry-report-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            showReportModal(entryId);
          });
        });

        // Bind reaction button events
        entriesContainer.querySelectorAll('.reaction-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var reactionsEl = btn.closest('.entry-reactions');
            var entryId = reactionsEl.dataset.entryId;
            var reactionType = btn.dataset.reaction;
            toggleReaction(entryId, reactionType, btn);
          });
        });

        // Initialize avatars - uses avatar_config from entry data attribute
        AvatarRenderer.initAvatars({
          selector: '.avatar-mini',
          configSource: function(canvas) {
            var entryEl = canvas.closest('.entry');
            if (!entryEl) return AvatarRenderer.loadFromStorage();
            
            // Try to get avatar_config from data attribute (from backend)
            var configAttr = entryEl.getAttribute('data-avatar-config');
            if (configAttr) {
              try {
                return JSON.parse(configAttr);
              } catch (e) {}
            }
            
            // Fall back to localStorage
            return AvatarRenderer.loadFromStorage();
          }
        });
      }

      // Edit modal
      function showEditModal(entryId, currentContent) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="edit-modal">
            <div class="edit-modal-title">EDIT ENTRY</div>
            <textarea class="edit-modal-textarea">${currentContent}</textarea>
            <div class="edit-modal-actions">
              <button class="cancel-btn" id="edit-cancel">CANCEL</button>
              <button class="reply-submit" id="edit-save">SAVE</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var textarea = overlay.querySelector('.edit-modal-textarea');
        var cancelBtn = overlay.querySelector('#edit-cancel');
        var saveBtn = overlay.querySelector('#edit-save');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        saveBtn.addEventListener('click', function() {
          var newContent = textarea.value.trim();
          if (!newContent) return;

          saveBtn.disabled = true;
          saveBtn.textContent = 'SAVING...';

          AuthState.apiRequest('/api/entries/' + entryId, {
            method: 'PUT',
            body: JSON.stringify({ content: newContent })
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('ENTRY UPDATED', 'info');
              overlay.remove();
              fetchThread(currentSignalId, currentPage).then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
            } else {
              Notify.show(data.message || data.error || 'UPDATE FAILED', 'error');
              saveBtn.disabled = false;
              saveBtn.textContent = 'SAVE';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            saveBtn.disabled = false;
            saveBtn.textContent = 'SAVE';
          });
        });
      }

      // Delete confirmation
      function showDeleteConfirm(entryId) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="confirm-modal">
            <div class="confirm-modal-text">DELETE THIS ENTRY?</div>
            <div class="confirm-modal-actions">
              <button class="cancel-btn" id="delete-cancel">CANCEL</button>
              <button class="confirm-delete-btn" id="delete-confirm">DELETE</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var cancelBtn = overlay.querySelector('#delete-cancel');
        var confirmBtn = overlay.querySelector('#delete-confirm');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        confirmBtn.addEventListener('click', function() {
          confirmBtn.disabled = true;
          confirmBtn.textContent = 'DELETING...';

          AuthState.apiRequest('/api/entries/' + entryId, {
            method: 'DELETE'
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('ENTRY DELETED', 'info');
              overlay.remove();
              fetchThread(currentSignalId, currentPage).then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
            } else {
              Notify.show(data.error || 'DELETE FAILED', 'error');
              confirmBtn.disabled = false;
              confirmBtn.textContent = 'DELETE';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'DELETE';
          });
        });
      }

      // Quote entry - prefill reply textarea
      function quoteEntry(alias, content) {
        var replyTextarea = document.getElementById('reply-content');
        var quotedText = '> ' + alias + ' wrote:\n> ' + content.split('\n').join('\n> ') + '\n\n';
        replyTextarea.value = quotedText + replyTextarea.value;
        replyTextarea.focus();
        replyTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }

      // Report modal
      function showReportModal(entryId) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="report-modal">
            <div class="report-modal-title">REPORT ENTRY</div>
            <div class="report-reasons">
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="spam"> SPAM
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="harassment"> HARASSMENT
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="inappropriate"> INAPPROPRIATE CONTENT
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="misinformation"> MISINFORMATION
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="other"> OTHER
              </label>
            </div>
            <textarea class="report-details-input" placeholder="Additional details (optional)..." rows="2" maxlength="500"></textarea>
            <div class="report-modal-actions">
              <button class="cancel-btn" id="report-cancel">CANCEL</button>
              <button class="report-submit-btn" id="report-submit">SUBMIT REPORT</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var cancelBtn = overlay.querySelector('#report-cancel');
        var submitBtn = overlay.querySelector('#report-submit');
        var detailsInput = overlay.querySelector('.report-details-input');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        submitBtn.addEventListener('click', function() {
          var selectedReason = overlay.querySelector('input[name="report-reason"]:checked');
          if (!selectedReason) {
            Notify.show('SELECT A REASON', 'error');
            return;
          }

          submitBtn.disabled = true;
          submitBtn.textContent = 'SUBMITTING...';

          AuthState.apiRequest('/api/reports', {
            method: 'POST',
            body: JSON.stringify({
              entry_id: entryId,
              reason: selectedReason.value,
              details: detailsInput.value.trim()
            })
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('REPORT SUBMITTED', 'info');
              overlay.remove();
            } else {
              Notify.show(data.error || 'REPORT FAILED', 'error');
              submitBtn.disabled = false;
              submitBtn.textContent = 'SUBMIT REPORT';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            submitBtn.disabled = false;
            submitBtn.textContent = 'SUBMIT REPORT';
          });
        });
      }

      // Toggle reaction on entry
      function toggleReaction(entryId, reactionType, btnEl) {
        btnEl.disabled = true;
        
        AuthState.apiRequest('/api/entries/' + entryId + '/react', {
          method: 'POST',
          body: JSON.stringify({ reaction_type: reactionType })
        })
        .then(function(data) {
          if (data.success) {
            var countEl = btnEl.querySelector('.reaction-count');
            var currentCount = parseInt(countEl.textContent) || 0;
            
            if (data.action === 'added') {
              countEl.textContent = currentCount + 1;
              btnEl.classList.add('reaction-active');
            } else {
              countEl.textContent = Math.max(0, currentCount - 1);
              btnEl.classList.remove('reaction-active');
            }
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'ERROR', 'error');
        })
        .finally(function() {
          btnEl.disabled = false;
        });
      }

      function applyFilters() {
        var filtered = allEntries.slice();
        
        // Search (client-side for current page)
        if (currentSearch) {
          var q = currentSearch.toLowerCase();
          filtered = filtered.filter(function(e) {
            return e.content.toLowerCase().indexOf(q) !== -1;
          });
        }
        
        // Sort
        if (currentSort === 'newest') {
          filtered.reverse();
        } else if (currentSort === 'oldest') {
          // default order is oldest first
        }
        
        renderEntries(filtered, allAvatarConfigs, currentPagination);
      }

      searchInput.addEventListener('input', function() {
        currentSearch = this.value;
        applyFilters();
      });

      sortBtns.forEach(function(btn) {
        btn.addEventListener('click', function() {
          sortBtns.forEach(function(b) { b.classList.remove('active'); });
          btn.classList.add('active');
          currentSort = btn.dataset.sort;
          applyFilters();
        });
      });

      /**
       * Fetch thread data from API
       */
      function fetchThread(signalId, page) {
        page = page || 1;
        var url = '/api/thread/' + signalId + '?page=' + page;
        
        return AuthState.apiRequest(url)
          .then(function(data) {
            if (data.success && data.thread) {
              var params = new URLSearchParams(window.location.search);
              var roomId = data.thread.roomId || params.get('room') || 'room-001';
              var sigNum = signalId ? signalId.replace('sig-', '') : '000';
              data.thread.signalIndex = 'SIG.' + sigNum;
              data.thread.roomName = 'NODE.' + roomId.replace('room-', '');
              // Build avatarConfigs map from entries
              data.avatarConfigs = {};
              if (data.entries) {
                data.entries.forEach(function(entry) {
                  if (entry.avatarConfig) {
                    data.avatarConfigs[entry.id] = entry.avatarConfig;
                  }
                });
              }
            }
            return data;
          });
      }

      /**
       * Initialize page
       */
      function init() {
        var signalId = getSignalIdFromUrl();
        currentSignalId = signalId;

        if (!signalId) {
          threadTitleEl.textContent = 'SIGNAL NOT FOUND';
          renderEntries([], {}, null);
          return;
        }

        fetchThread(signalId, 1)
          .then(function(data) {
            if (data.success) {
              updateSignalMeta(data.thread);
              roomNameEl.textContent = data.thread.roomName || 'NODE.001';
              allEntries = data.entries || [];
              allAvatarConfigs = data.avatarConfigs || {};
              currentPagination = data.pagination || null;
              renderEntries(allEntries, allAvatarConfigs, currentPagination);
              
              // Check bookmark and subscription status
              checkBookmarkStatus(data.thread.id);
              checkSubscriptionStatus(data.thread.id);
              
              // Load poll if exists
              loadPoll(data.thread.id);
              
              // Mark as read with last entry ID
              if (allEntries.length > 0) {
                var lastEntryId = allEntries[allEntries.length - 1].id;
                markThreadAsRead(data.thread.id, lastEntryId);
              }
            } else {
              threadTitleEl.textContent = 'ERROR: ' + (data.error || 'UNKNOWN');
              allEntries = [];
              allAvatarConfigs = {};
              currentPagination = null;
              renderEntries([], {}, null);
              Notify.show(data.error || 'FAILED TO LOAD SIGNAL', 'error');
            }
          })
          .catch(function(err) {
            threadTitleEl.textContent = 'CONNECTION ERROR';
            allEntries = [];
            allAvatarConfigs = {};
            currentPagination = null;
            renderEntries([], {}, null);
            Notify.show(err.message || 'CONNECTION ERROR', 'error');
          });
      }
      
      // Bookmark functionality
      var bookmarkBtn = document.getElementById('bookmark-btn');
      var currentThreadDbId = null;
      
      function checkBookmarkStatus(threadId) {
        currentThreadDbId = threadId;
        AuthState.apiRequest('/api/bookmarks/' + threadId + '/check')
          .then(function(data) {
            if (data.success && data.isBookmarked) {
              bookmarkBtn.textContent = '[SAVED]';
              bookmarkBtn.classList.add('bookmarked');
            } else {
              bookmarkBtn.textContent = '[SAVE]';
              bookmarkBtn.classList.remove('bookmarked');
            }
          });
      }
      
      bookmarkBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        bookmarkBtn.disabled = true;
        
        AuthState.apiRequest('/api/bookmarks/' + currentThreadDbId, { method: 'POST' })
          .then(function(data) {
            if (data.success) {
              if (data.action === 'added') {
                bookmarkBtn.textContent = '[SAVED]';
                bookmarkBtn.classList.add('bookmarked');
                Notify.show('THREAD SAVED', 'info');
              } else {
                bookmarkBtn.textContent = '[SAVE]';
                bookmarkBtn.classList.remove('bookmarked');
                Notify.show('BOOKMARK REMOVED', 'info');
              }
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
          })
          .finally(function() {
            bookmarkBtn.disabled = false;
          });
      });

      // Subscribe functionality
      var subscribeBtn = document.getElementById('subscribe-btn');
      var isSubscribed = false;

      function checkSubscriptionStatus(threadId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/subscribe')
          .then(function(data) {
            if (data.success) {
              isSubscribed = data.subscribed;
              updateSubscribeButton();
            }
          });
      }

      function updateSubscribeButton() {
        if (isSubscribed) {
          subscribeBtn.textContent = '[WATCHING]';
          subscribeBtn.classList.add('subscribed');
        } else {
          subscribeBtn.textContent = '[WATCH]';
          subscribeBtn.classList.remove('subscribed');
        }
      }

      subscribeBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        subscribeBtn.disabled = true;
        
        var method = isSubscribed ? 'DELETE' : 'POST';
        AuthState.apiRequest('/api/threads/' + currentThreadDbId + '/subscribe', { method: method })
          .then(function(data) {
            if (data.success) {
              isSubscribed = data.subscribed;
              updateSubscribeButton();
              Notify.show(isSubscribed ? 'SUBSCRIBED' : 'UNSUBSCRIBED', 'info');
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
          })
          .finally(function() {
            subscribeBtn.disabled = false;
          });
      });

      // Mark thread as read when viewing
      function markThreadAsRead(threadId, lastEntryId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/read', {
          method: 'POST',
          body: JSON.stringify({ last_entry_id: lastEntryId })
        });
      }

      // Poll functionality
      var pollContainer = document.getElementById('poll-container');
      var pollQuestion = document.getElementById('poll-question');
      var pollMeta = document.getElementById('poll-meta');
      var pollOptions = document.getElementById('poll-options');
      var pollVoteBtn = document.getElementById('poll-vote-btn');
      var pollTotal = document.getElementById('poll-total');
      var currentPoll = null;
      var selectedOptions = [];

      function loadPoll(threadId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/poll')
          .then(function(data) {
            if (data.success && data.poll) {
              currentPoll = data.poll;
              renderPoll(data.poll);
            }
          });
      }

      function renderPoll(poll) {
        pollContainer.style.display = 'block';
        pollQuestion.textContent = poll.question;
        
        var metaText = 'Created by ' + poll.createdBy;
        if (poll.endsAt) {
          var endsAt = new Date(poll.endsAt);
          metaText += ' ‚Ä¢ Ends: ' + endsAt.toLocaleDateString();
          if (poll.isExpired) {
            metaText += ' (EXPIRED)';
          }
        }
        if (poll.allowMultiple) {
          metaText += ' ‚Ä¢ Multiple choice';
        }
        pollMeta.textContent = metaText;

        var hasVoted = poll.userVotes && poll.userVotes.length > 0;
        selectedOptions = poll.userVotes ? poll.userVotes.slice() : [];

        pollOptions.innerHTML = poll.options.map(function(opt) {
          var isSelected = selectedOptions.includes(opt.id);
          var votedClass = hasVoted || poll.isExpired ? 'voted' : '';
          var selectedClass = isSelected ? 'selected' : '';
          
          var barWidth = hasVoted || poll.isExpired ? opt.percentage : 0;
          
          return '<div class="poll-option-wrapper">' +
            '<div class="poll-option-bar" style="width: ' + barWidth + '%;"></div>' +
            '<label class="poll-option ' + votedClass + ' ' + selectedClass + '" data-option-id="' + opt.id + '">' +
              (hasVoted || poll.isExpired ? '' : '<input type="' + (poll.allowMultiple ? 'checkbox' : 'radio') + '" name="poll-option" value="' + opt.id + '" ' + (isSelected ? 'checked' : '') + '>') +
              '<span class="poll-option-text">' + escapeHtml(opt.text) + '</span>' +
              '<span class="poll-option-stats">' + opt.voteCount + ' (' + opt.percentage + '%)</span>' +
            '</label>' +
          '</div>';
        }).join('');

        pollTotal.textContent = poll.totalVoters + ' total voter' + (poll.totalVoters !== 1 ? 's' : '');

        // Show vote button if not voted and not expired
        if (!hasVoted && !poll.isExpired) {
          pollVoteBtn.style.display = 'inline-block';
          pollVoteBtn.disabled = true;

          // Bind option selection
          pollOptions.querySelectorAll('input').forEach(function(input) {
            input.addEventListener('change', function() {
              if (currentPoll.allowMultiple) {
                if (this.checked) {
                  selectedOptions.push(parseInt(this.value));
                } else {
                  selectedOptions = selectedOptions.filter(function(id) { return id !== parseInt(input.value); });
                }
              } else {
                selectedOptions = [parseInt(this.value)];
              }
              pollVoteBtn.disabled = selectedOptions.length === 0;
              
              // Update selected styling
              pollOptions.querySelectorAll('.poll-option').forEach(function(opt) {
                var optId = parseInt(opt.dataset.optionId);
                if (selectedOptions.includes(optId)) {
                  opt.classList.add('selected');
                } else {
                  opt.classList.remove('selected');
                }
              });
            });
          });
        } else {
          pollVoteBtn.style.display = 'none';
        }
      }

      function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      pollVoteBtn.addEventListener('click', function() {
        if (!currentPoll || selectedOptions.length === 0) return;
        pollVoteBtn.disabled = true;
        pollVoteBtn.textContent = 'VOTING...';

        AuthState.apiRequest('/api/polls/' + currentPoll.id + '/vote', {
          method: 'POST',
          body: JSON.stringify({ optionIds: selectedOptions })
        })
        .then(function(data) {
          if (data.success) {
            Notify.show('VOTE RECORDED', 'info');
            loadPoll(currentThreadDbId);
          } else {
            Notify.show(data.error || 'VOTE FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'VOTE ERROR', 'error');
        })
        .finally(function() {
          pollVoteBtn.textContent = 'VOTE';
          pollVoteBtn.disabled = false;
        });
      });

      // Reply form handler
      var replyForm = document.getElementById('reply-form');
      var replyContent = document.getElementById('reply-content');
      
      replyForm.addEventListener('submit', function(e) {
        e.preventDefault();
        var content = replyContent.value.trim();
        if (!content) return;
        
        var submitBtn = replyForm.querySelector('.reply-submit');
        submitBtn.disabled = true;
        submitBtn.textContent = 'TRANSMITTING...';
        
        AuthState.apiRequest('/api/entries', {
          method: 'POST',
          body: JSON.stringify({
            threadId: parseInt(currentSignalId),
            content: content
          })
        })
        .then(function(data) {
          if (data.success) {
            replyContent.value = '';
            Notify.show('ENTRY RECORDED', 'info');
            // Reload entries
            fetchThread(currentSignalId, currentPage)
              .then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  allAvatarConfigs = data.avatarConfigs || {};
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
          } else {
            Notify.show(data.error || 'TRANSMISSION FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'CONNECTION ERROR', 'error');
        })
        .finally(function() {
          submitBtn.disabled = false;
          submitBtn.textContent = 'TRANSMIT';
        });
      });

      // Admin controls for pin/lock
      var pinBtn = document.getElementById('pin-btn');
      var lockBtn = document.getElementById('lock-btn');

      pinBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        pinBtn.disabled = true;
        
        AuthState.apiRequest('/api/admin/threads/' + currentThreadDbId + '/pin', { method: 'PUT' })
          .then(function(data) {
            if (data.success) {
              currentThreadData.isPinned = data.is_pinned;
              updateThreadBadges(currentThreadData);
              updateAdminControls(currentThreadData);
              Notify.show(data.is_pinned ? 'THREAD PINNED' : 'THREAD UNPINNED', 'info');
            }
          })
          .catch(function(err) {
            Notify.show('ERROR', 'error');
          })
          .finally(function() {
            pinBtn.disabled = false;
          });
      });

      lockBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        lockBtn.disabled = true;
        
        AuthState.apiRequest('/api/admin/threads/' + currentThreadDbId + '/lock', { method: 'PUT' })
          .then(function(data) {
            if (data.success) {
              currentThreadData.isLocked = data.is_locked;
              updateThreadBadges(currentThreadData);
              updateAdminControls(currentThreadData);
              Notify.show(data.is_locked ? 'THREAD LOCKED' : 'THREAD UNLOCKED', 'info');
              // Update reply form visibility
              updateReplyFormForLock(data.is_locked);
            }
          })
          .catch(function(err) {
            Notify.show('ERROR', 'error');
          })
          .finally(function() {
            lockBtn.disabled = false;
          });
      });

      function updateReplyFormForLock(isLocked) {
        var replyFormContainer = document.querySelector('.reply-form-container');
        if (isLocked && !AuthState.isAdmin()) {
          replyFormContainer.innerHTML = '<div class="locked-notice">üîí THIS THREAD IS LOCKED</div>';
        }
      }

      // Back to top button
      var backToTopBtn = document.getElementById('back-to-top');
      
      window.addEventListener('scroll', function() {
        if (window.scrollY > 300) {
          backToTopBtn.classList.add('visible');
        } else {
          backToTopBtn.classList.remove('visible');
        }
      });
      
      backToTopBtn.addEventListener('click', function() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // 'r' - Focus reply textarea
        if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          replyContent.focus();
        }
        
        // 'g' then 't' - Go to top
        if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // 'g' then 'b' - Go to bottom
        if (e.key === 'b' && !e.ctrlKey && !e.metaKey) {
          window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
        
        // 'j' - Scroll down
        if (e.key === 'j' && !e.ctrlKey && !e.metaKey) {
          window.scrollBy({ top: 100, behavior: 'smooth' });
        }
        
        // 'k' - Scroll up
        if (e.key === 'k' && !e.ctrlKey && !e.metaKey) {
          window.scrollBy({ top: -100, behavior: 'smooth' });
        }
        
        // '[' - Previous page
        if (e.key === '[' && currentPagination && currentPage > 1) {
          currentPage--;
          fetchThread(currentSignalId, currentPage);
        }
        
        // ']' - Next page
        if (e.key === ']' && currentPagination && currentPage < currentPagination.totalPages) {
          currentPage++;
          fetchThread(currentSignalId, currentPage);
        }
        
        // '?' - Show keyboard shortcuts help
        if (e.key === '?' && e.shiftKey) {
          Notify.show('SHORTCUTS: r=reply, t=top, b=bottom, j/k=scroll, []=prev/next page', 'info');
        }
      });

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      document.querySelector('[data-action="logout"]').addEventListener('click', function(e) {
        e.preventDefault();
        AuthState.logout();
      });
    })();
  </script>

</body>
</html>
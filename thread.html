<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASPD Forum ‚Äî Thread</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="stylesheet" href="css/style.css?v=20251229">
</head>
<body>

  <!-- Skip to main content -->
  <a href="#entries-container" class="skip-link">Skip to thread entries</a>

  <!-- Noise Overlay -->
  <div class="noise" aria-hidden="true"></div>

  <!-- Thread Layout -->
  <div class="thread-container" data-page="thread" data-signal-id="">

    <!-- Header -->
    <header class="thread-header" data-component="thread-header" role="banner">
      <nav class="thread-header-left" aria-label="Breadcrumb">
        <a href="room.html" class="thread-back" data-bind="back-link" aria-label="Back to room">‚Üê INDEX</a>
        <span class="thread-divider" aria-hidden="true">/</span>
        <span class="thread-room" data-bind="room-name">NODE.000</span>
      </nav>
      <nav class="header-right" aria-label="User navigation">
        <span class="thread-entry-count" data-bind="entry-count" aria-live="polite"><span id="entry-count">0</span> RECORDS</span>
        <a href="#" class="header-notifications" id="notif-bell" title="Notifications" aria-label="View notifications" role="button">
          <span class="notif-icon" aria-hidden="true">[!]</span>
          <span class="notif-badge" id="notif-badge" style="display: none;" aria-live="polite">0</span>
        </a>
        <a href="profile.html" class="header-profile" aria-label="View profile">PROFILE</a>
        <a href="messages.html" class="header-messages" aria-label="Messages">MSG</a>
        <a href="#" class="header-exit" data-action="logout" aria-label="Sign out">EXIT</a>
      </nav>
    </header>

    <!-- Thread Title -->
    <div class="thread-title-bar" role="heading" aria-level="1">
      <h1 class="thread-title" data-bind="thread-title">Loading...</h1>
      <span class="thread-status-badges" id="thread-badges" aria-live="polite"></span>
      <button class="subscribe-btn" id="subscribe-btn" title="Subscribe to thread" aria-label="Subscribe to this thread" aria-pressed="false">[WATCH]</button>
      <button class="bookmark-btn" id="bookmark-btn" title="Bookmark this thread" aria-label="Bookmark this thread" aria-pressed="false">[SAVE]</button>
      <button class="share-btn" id="share-btn" title="Copy link to clipboard" aria-label="Share this thread">[SHARE]</button>
      <span class="thread-slow-mode" id="slow-mode-indicator" style="display: none;" role="status" aria-live="polite"></span>
      <!-- Admin Controls -->
      <div class="thread-admin-controls" id="thread-admin-controls" style="display: none;" role="group" aria-label="Admin controls">
        <button class="admin-btn" id="pin-btn" title="Pin/Unpin thread" aria-label="Pin or unpin thread" aria-pressed="false">[PIN]</button>
        <button class="admin-btn" id="lock-btn" title="Lock/Unlock thread" aria-label="Lock or unlock thread" aria-pressed="false">[LOCK]</button>
      </div>
    </div>

    <!-- Live Presence Bar -->
    <div class="presence-bar" id="presence-bar" aria-label="Users viewing this thread" role="status">
      <div class="presence-viewers" id="presence-viewers" title="Users viewing this thread"></div>
      <div class="presence-typing" id="presence-typing" aria-live="polite" style="display: none;"></div>
    </div>

    <!-- Filter Bar -->
    <div class="filter-bar" role="search">
      <label for="search-input" class="sr-only">Search entries in this thread</label>
      <input type="text" id="search-input" class="filter-input" placeholder="SEARCH ENTRIES..." aria-label="Search entries">
      <div class="sort-controls" role="group" aria-label="Sort options">
        <button class="sort-btn active" data-sort="default" aria-pressed="true">DEFAULT</button>
        <button class="sort-btn" data-sort="newest" aria-pressed="false">NEWEST</button>
        <button class="sort-btn" data-sort="oldest" aria-pressed="false">OLDEST</button>
      </div>
    </div>

    <!-- Poll Container (if thread has a poll) -->
    <section class="poll-container" id="poll-container" style="display: none;" aria-label="Thread poll">
      <h2 class="poll-question" id="poll-question"></h2>
      <div class="poll-meta" id="poll-meta" aria-live="polite"></div>
      <div class="poll-options" id="poll-options" role="group" aria-label="Poll options"></div>
      <button class="poll-vote-btn" id="poll-vote-btn" style="display: none;" aria-label="Submit your vote">VOTE</button>
      <div class="poll-total" id="poll-total" aria-live="polite"></div>
    </section>

    <!-- Entry List - Container for dynamic entries -->
    <main class="entry-list" id="entries-container" data-container="entries" role="main" aria-label="Thread entries">
      <!-- PLACEHOLDER: Entry elements will be injected here by JS -->
    </main>

    <!-- Pagination -->
    <div id="pagination-container"></div>

    <!-- Reply Form -->
    <section class="reply-form-container" id="reply-form-container" aria-label="Reply to thread">
      <form id="reply-form" class="reply-form" aria-label="Post a reply">
        <!-- Markdown Toolbar -->
        <div class="markdown-toolbar" role="toolbar" aria-label="Text formatting">
          <button type="button" class="md-btn" data-md="bold" title="Bold (**text**)" aria-label="Bold"><strong>B</strong></button>
          <button type="button" class="md-btn" data-md="italic" title="Italic (*text*)" aria-label="Italic"><em>I</em></button>
          <button type="button" class="md-btn" data-md="strike" title="Strikethrough (~~text~~)" aria-label="Strikethrough"><del>S</del></button>
          <button type="button" class="md-btn" data-md="code" title="Code (`code`)" aria-label="Code">&lt;/&gt;</button>
          <button type="button" class="md-btn" data-md="link" title="Link ([text](url))" aria-label="Insert link">üîó</button>
          <button type="button" class="md-btn" data-md="quote" title="Quote (> text)" aria-label="Quote">&gt;</button>
          <button type="button" class="md-btn" data-md="list" title="List (- item)" aria-label="List">‚ò∞</button>
          <button type="button" class="md-btn" data-md="h1" title="Heading (#)" aria-label="Heading">H</button>
          <button type="button" class="md-btn" data-md="image" title="Upload Image" aria-label="Upload image">üì∑</button>
          <input type="file" id="image-upload" accept="image/jpeg,image/png,image/gif,image/webp" style="display: none;">
          <button type="button" class="md-btn md-preview-btn" id="preview-toggle" title="Toggle Preview" aria-label="Toggle preview">üëÅ</button>
          <span class="markdown-help" aria-hidden="true">MARKDOWN SUPPORTED</span>
        </div>
        <div class="reply-editor-container">
          <label for="reply-content" class="sr-only">Your reply</label>
          <textarea id="reply-content" class="reply-textarea" placeholder="ENTER YOUR RESPONSE... (Markdown supported: **bold**, *italic*, `code`, > quote)" rows="3" required aria-label="Write your reply"></textarea>
          <div id="reply-preview" class="reply-preview" style="display: none;">
            <div class="preview-label">PREVIEW</div>
            <div class="preview-content" id="preview-content"></div>
          </div>
        </div>
        <div class="reply-actions">
          <div class="reply-options">
            <label class="ghost-toggle" id="ghost-toggle-container" title="Post without revealing your identity">
              <input type="checkbox" id="ghost-mode-toggle">
              <span class="ghost-toggle-icon">[?]</span>
              <span class="ghost-toggle-label">ANONYMOUS</span>
            </label>
            <div class="vault-selector" id="vault-selector">
              <label class="vault-toggle" title="Restrict post visibility by reputation">
                <input type="checkbox" id="vault-mode-toggle">
                <span class="vault-toggle-icon">[V]</span>
                <span class="vault-toggle-label">VAULT</span>
              </label>
              <select id="vault-level" class="vault-level-select" disabled>
                <option value="">PUBLIC</option>
                <option value="10">10+ REP</option>
                <option value="25">25+ REP</option>
                <option value="50">50+ REP</option>
                <option value="100">100+ REP</option>
              </select>
            </div>
          </div>
          <button type="submit" class="reply-submit" aria-label="Submit reply">TRANSMIT</button>
        </div>
      </form>
    </section>

    <!-- Jump to Unread Button -->
    <button class="jump-unread-btn" id="jump-unread-btn" title="Jump to first unread" aria-label="Jump to first unread post">‚Üì NEW</button>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="back-to-top" title="Back to top" aria-label="Scroll to top of page">‚Üë TOP</button>

    <!-- Footer -->
    <footer class="thread-footer" data-component="thread-footer" role="contentinfo">
      <span data-bind="signal-id">SIG.000</span>
      <span data-bind="connection-status" aria-live="polite">ONLINE</span>
      <span class="online-count-small" id="online-count" aria-live="polite">0 ONLINE</span>
    </footer>

  </div>

  <!-- Theme Toggle -->
  <button class="theme-toggle" id="theme-toggle" aria-label="Change theme" title="Toggle theme">üé®</button>

  <!-- Mobile Bottom Navigation -->
  <nav class="mobile-nav" aria-label="Mobile navigation">
    <a href="forum.html" class="mobile-nav-item">
      <span class="mobile-nav-icon">‚åÇ</span>
      <span class="mobile-nav-label">Home</span>
    </a>
    <a href="search.html" class="mobile-nav-item">
      <span class="mobile-nav-icon">‚åï</span>
      <span class="mobile-nav-label">Search</span>
    </a>
    <a href="#" class="mobile-nav-item" id="mobile-notif-btn">
      <span class="mobile-nav-icon">!</span>
      <span class="mobile-nav-label">Alerts</span>
      <span class="nav-badge" id="mobile-notif-badge"></span>
    </a>
    <a href="messages.html" class="mobile-nav-item">
      <span class="mobile-nav-icon">‚úâ</span>
      <span class="mobile-nav-label">Msg</span>
    </a>
    <a href="profile.html" class="mobile-nav-item">
      <span class="mobile-nav-icon">‚óâ</span>
      <span class="mobile-nav-label">Profile</span>
    </a>
  </nav>

  <!-- Revision History Modal -->
  <div class="modal-overlay" id="revision-modal" role="dialog" aria-modal="true" aria-labelledby="revision-title">
    <div class="modal-content revision-modal">
      <h2 class="modal-title" id="revision-title">EDIT HISTORY</h2>
      <div class="revision-list" id="revision-list">
        <div class="empty-state">Loading...</div>
      </div>
      <div class="modal-actions">
        <button class="modal-close-btn" id="revision-close">CLOSE</button>
      </div>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div class="shortcuts-modal-overlay" id="shortcuts-modal" role="dialog" aria-modal="true" aria-labelledby="shortcuts-title">
    <div class="shortcuts-modal">
      <h2 class="shortcuts-title" id="shortcuts-title">KEYBOARD SHORTCUTS</h2>
      <div class="shortcuts-section">
        <h3 class="shortcuts-section-title">Navigation</h3>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">?</span></span><span class="shortcut-desc">Show this help</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">g</span><span class="shortcut-key">h</span></span><span class="shortcut-desc">Go to home</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">/</span></span><span class="shortcut-desc">Focus search</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">Esc</span></span><span class="shortcut-desc">Close modal</span></div>
      </div>
      <div class="shortcuts-section">
        <h3 class="shortcuts-section-title">Thread View</h3>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">r</span></span><span class="shortcut-desc">Focus reply</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">j</span></span><span class="shortcut-desc">Next entry</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">k</span></span><span class="shortcut-desc">Previous entry</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">t</span></span><span class="shortcut-desc">Go to top</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">b</span></span><span class="shortcut-desc">Go to bottom</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">[</span></span><span class="shortcut-desc">Previous page</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">]</span></span><span class="shortcut-desc">Next page</span></div>
      </div>
      <button class="shortcuts-close" id="shortcuts-close">CLOSE [ESC]</button>
    </div>
  </div>

  <!-- Scroll Progress -->
  <div class="scroll-progress" id="scroll-progress"></div>

  <script src="js/utils.js"></script>
  <script src="js/auth-state.js"></script>
  <script src="js/notify.js"></script>
  <script src="js/notifications.js"></script>
  <script src="js/avatar-renderer.js"></script>
  <script src="js/ui-components.js"></script>
  <script src="js/websocket.js"></script>
  <script>
    (function() {
      'use strict';

      Notify.checkUrlNotify();

      if (!AuthState.gateProtected()) return;

      var entriesContainer = document.getElementById('entries-container');
      var paginationContainer = document.getElementById('pagination-container');
      var entryCountEl = document.getElementById('entry-count');
      var slowModeIndicator = document.getElementById('slow-mode-indicator');
      var threadContainer = document.querySelector('[data-page="thread"]');
      var threadTitleEl = document.querySelector('[data-bind="thread-title"]');
      var roomNameEl = document.querySelector('[data-bind="room-name"]');
      var signalIdEl = document.querySelector('[data-bind="signal-id"]');
      var backLinkEl = document.querySelector('[data-bind="back-link"]');
      var searchInput = document.getElementById('search-input');
      var sortBtns = document.querySelectorAll('.sort-btn');

      var allEntries = [];
      var allAvatarConfigs = {};
      var currentSort = 'default';
      var currentSearch = '';
      var currentPage = 1;
      var currentPagination = null;
      var currentSignalId = null;
      var opUserId = null; // Original poster's user ID for OP badge
      
      // Get current user ID from JWT token
      var currentUserId = null;
      var currentUserAlias = null;
      var currentUserAvatarConfig = null;
      try {
        var token = AuthState.getToken();
        if (token) {
          var payload = JSON.parse(atob(token.split('.')[1]));
          currentUserId = payload.userId;
          currentUserAlias = payload.alias;
        }
      } catch (e) {}

      // Load user's avatar config for presence
      try {
        var storedConfig = localStorage.getItem('avatarConfig');
        if (storedConfig) {
          currentUserAvatarConfig = JSON.parse(storedConfig);
        }
      } catch (e) {}

      // ========================================
      // LIVE PRESENCE SYSTEM
      // ========================================
      var presenceViewersEl = document.getElementById('presence-viewers');
      var presenceTypingEl = document.getElementById('presence-typing');
      var activeViewers = new Map(); // userId -> { alias, avatarConfig }
      var typingUsers = new Map(); // userId -> { alias, timeout }

      // Initial render showing connecting state
      presenceViewersEl.innerHTML = '<span class="presence-count">CONNECTING</span>';

      function renderViewers() {
        if (activeViewers.size === 0) {
          presenceViewersEl.innerHTML = '<span class="presence-count">VIEWING ALONE</span>';
          return;
        }

        var html = '';
        var count = 0;
        var maxVisible = 8;

        activeViewers.forEach(function(data, viewerId) {
          if (count < maxVisible) {
            var avatarHtml = '';
            if (data.avatarConfig) {
              avatarHtml = '<canvas class="presence-viewer pulsing" data-user-id="' + viewerId + '" width="24" height="24" title="' + escapeHtml(data.alias) + '"></canvas>';
            } else {
              // Fallback to initial letter
              avatarHtml = '<div class="presence-viewer pulsing" data-user-id="' + viewerId + '" style="display: flex; align-items: center; justify-content: center; background: var(--bg-tertiary); font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);" title="' + escapeHtml(data.alias) + '">' + data.alias.charAt(0).toUpperCase() + '<span class="presence-viewer-tooltip">' + escapeHtml(data.alias) + '</span></div>';
            }
            html += avatarHtml;
          }
          count++;
        });

        if (count > maxVisible) {
          html += '<span class="presence-count">+' + (count - maxVisible) + ' MORE</span>';
        }

        html += '<span class="presence-count">' + count + ' VIEWING</span>';
        presenceViewersEl.innerHTML = html;

        // Render avatar canvases
        presenceViewersEl.querySelectorAll('canvas.presence-viewer').forEach(function(canvas) {
          var viewerId = parseInt(canvas.dataset.userId);
          var viewerData = activeViewers.get(viewerId);
          if (viewerData && viewerData.avatarConfig) {
            try {
              AvatarRenderer.render(canvas, viewerData.avatarConfig);
            } catch (e) {}
          }
        });

        // Add tooltips to canvases
        presenceViewersEl.querySelectorAll('canvas.presence-viewer').forEach(function(canvas) {
          var viewerId = parseInt(canvas.dataset.userId);
          var viewerData = activeViewers.get(viewerId);
          if (viewerData) {
            var tooltip = document.createElement('span');
            tooltip.className = 'presence-viewer-tooltip';
            tooltip.textContent = viewerData.alias;
            canvas.parentNode.style.position = 'relative';
            var wrapper = document.createElement('div');
            wrapper.style.position = 'relative';
            wrapper.style.display = 'inline-block';
            canvas.parentNode.insertBefore(wrapper, canvas);
            wrapper.appendChild(canvas);
            wrapper.appendChild(tooltip);
          }
        });
      }

      function renderTypingIndicator() {
        if (typingUsers.size === 0) {
          presenceTypingEl.style.display = 'none';
          return;
        }

        var names = [];
        typingUsers.forEach(function(data) {
          names.push(data.alias);
        });

        var text = '';
        if (names.length === 1) {
          text = names[0] + ' is typing';
        } else if (names.length === 2) {
          text = names[0] + ' and ' + names[1] + ' are typing';
        } else {
          text = names.length + ' people are typing';
        }

        presenceTypingEl.innerHTML = '<span>' + escapeHtml(text) + '</span><span class="typing-dots"><span></span><span></span><span></span></span>';
        presenceTypingEl.style.display = 'flex';
      }

      function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // WebSocket presence handlers
      ForumWS.on('viewerList', function(data) {
        activeViewers.clear();
        (data.viewers || []).forEach(function(viewer) {
          activeViewers.set(viewer.userId, {
            alias: viewer.alias,
            avatarConfig: viewer.avatarConfig
          });
        });
        renderViewers();
      });

      ForumWS.on('viewerJoined', function(data) {
        activeViewers.set(data.userId, {
          alias: data.alias,
          avatarConfig: data.avatarConfig
        });
        renderViewers();
      });

      ForumWS.on('viewerLeft', function(data) {
        activeViewers.delete(data.userId);
        typingUsers.delete(data.userId);
        renderViewers();
        renderTypingIndicator();
      });

      ForumWS.on('typing', function(data) {
        if (data.userId === currentUserId) return; // Ignore self
        
        // Clear existing timeout
        if (typingUsers.has(data.userId)) {
          clearTimeout(typingUsers.get(data.userId).timeout);
        }
        
        // Add with auto-clear timeout
        var timeout = setTimeout(function() {
          typingUsers.delete(data.userId);
          renderTypingIndicator();
        }, 4000);
        
        typingUsers.set(data.userId, {
          alias: data.alias,
          timeout: timeout
        });
        renderTypingIndicator();
      });

      ForumWS.on('stopTyping', function(data) {
        if (typingUsers.has(data.userId)) {
          clearTimeout(typingUsers.get(data.userId).timeout);
          typingUsers.delete(data.userId);
          renderTypingIndicator();
        }
      });

      // Join thread presence when connected
      ForumWS.on('connected', function() {
        if (currentSignalId) {
          ForumWS.viewThread(currentSignalId, currentUserAvatarConfig);
        }
      });

      // Leave on page unload
      window.addEventListener('beforeunload', function() {
        if (currentSignalId) {
          ForumWS.leaveThread(currentSignalId);
        }
      });

      // Leave on visibility change (tab switch)
      document.addEventListener('visibilitychange', function() {
        if (document.hidden && currentSignalId) {
          ForumWS.leaveThread(currentSignalId);
        } else if (!document.hidden && currentSignalId && ForumWS.isConnected()) {
          ForumWS.viewThread(currentSignalId, currentUserAvatarConfig);
        }
      });

      function getSignalIdFromUrl() {
        var params = new URLSearchParams(window.location.search);
        return params.get('id');
      }

      function updateSlowModeIndicator(interval) {
        if (interval && interval > 0) {
          slowModeIndicator.textContent = 'SLOW MODE: ' + interval + 's';
          slowModeIndicator.style.display = 'inline';
        } else {
          slowModeIndicator.style.display = 'none';
        }
      }

      function updateSignalMeta(signalMeta) {
        if (!signalMeta) return;
        var signalId = signalMeta.id || '';
        var signalIndex = signalMeta.signalIndex || 'SIG.000';
        var roomId = signalMeta.roomId || '';
        threadContainer.setAttribute('data-signal-id', signalId);
        threadTitleEl.textContent = signalMeta.title || 'Untitled';
        signalIdEl.textContent = signalIndex;
        if (roomId) {
          backLinkEl.href = 'room.html?id=' + roomId;
        }
        document.title = 'ASPD Forum ‚Äî ' + (signalMeta.title || 'Thread');
        updateSlowModeIndicator(signalMeta.slowModeInterval);
        updateThreadBadges(signalMeta);
        updateAdminControls(signalMeta);
      }

      function updateThreadBadges(threadData) {
        var badgesEl = document.getElementById('thread-badges');
        var badges = [];
        if (threadData.isPinned) badges.push('<span class="thread-badge pinned">üìå PINNED</span>');
        if (threadData.isLocked) badges.push('<span class="thread-badge locked">üîí LOCKED</span>');
        badgesEl.innerHTML = badges.join(' ');
      }

      var currentThreadData = null;

      function updateAdminControls(threadData) {
        currentThreadData = threadData;
        if (!AuthState.isAdmin()) return;
        
        var adminControls = document.getElementById('thread-admin-controls');
        var pinBtn = document.getElementById('pin-btn');
        var lockBtn = document.getElementById('lock-btn');
        
        adminControls.style.display = 'flex';
        pinBtn.textContent = threadData.isPinned ? '[UNPIN]' : '[PIN]';
        lockBtn.textContent = threadData.isLocked ? '[UNLOCK]' : '[LOCK]';
      }

      /**
       * Render entries to the list
       * @param {Array} entries - Array of entry objects
       * @param {Object} avatarConfigs - Map of userId to avatar config (from backend)
       * @param {Object} pagination - Pagination info
       */
      function renderEntries(entries, avatarConfigs, pagination) {
        avatarConfigs = avatarConfigs || {};
        if (!entries || !entries.length) {
          entriesContainer.innerHTML = '<div class="empty-state" data-empty="entries">NO RECORDS AVAILABLE</div>';
          entryCountEl.textContent = '0';
          paginationContainer.innerHTML = '';
          return;
        }
        entriesContainer.innerHTML = entries.map(function(entry) {
          return UIComponents.entryElement(entry, currentUserId, opUserId);
        }).join('');
        entryCountEl.textContent = pagination ? pagination.total : entries.length;

        // Render pagination
        paginationContainer.innerHTML = UIComponents.paginationControls(pagination);
        
        // Bind pagination events
        paginationContainer.querySelectorAll('.pagination-btn:not(.pagination-go-btn)').forEach(function(btn) {
          btn.addEventListener('click', function() {
            if (btn.disabled) return;
            currentPage = parseInt(btn.dataset.page);
            fetchThread(currentSignalId, currentPage);
          });
        });
        
        // Bind pagination jump events
        var jumpInput = paginationContainer.querySelector('.pagination-jump-input');
        var goBtn = paginationContainer.querySelector('.pagination-go-btn');
        if (jumpInput && goBtn) {
          goBtn.addEventListener('click', function() {
            var pageNum = parseInt(jumpInput.value);
            if (pageNum >= 1 && pageNum <= pagination.totalPages) {
              currentPage = pageNum;
              fetchThread(currentSignalId, currentPage);
            }
          });
          jumpInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              goBtn.click();
            }
          });
        }

        // Bind edit button events
        entriesContainer.querySelectorAll('.entry-edit-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            var entryEl = btn.closest('.entry');
            var content = entryEl.querySelector('.entry-content p').textContent;
            showEditModal(entryId, content);
          });
        });

        // Bind delete button events
        entriesContainer.querySelectorAll('.entry-delete-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            showDeleteConfirm(entryId);
          });
        });

        // Bind quote button events
        entriesContainer.querySelectorAll('.entry-quote-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryEl = btn.closest('.entry');
            var alias = btn.dataset.alias;
            var content = entryEl.querySelector('.entry-content p').textContent;
            quoteEntry(alias, content);
          });
        });

        // Bind report button events
        entriesContainer.querySelectorAll('.entry-report-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            showReportModal(entryId);
          });
        });

        // Bind edit history link events
        entriesContainer.querySelectorAll('.entry-history-link').forEach(function(link) {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            var entryId = link.dataset.entryId;
            showRevisionHistory(entryId);
          });
        });

        // Bind vote button events
        entriesContainer.querySelectorAll('.vote-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var votesEl = btn.closest('.entry-votes');
            var entryId = votesEl.dataset.entryId;
            var voteValue = parseInt(btn.dataset.vote);
            handleVote(entryId, voteValue, btn);
          });
        });

        // Initialize avatars - uses avatar_config from entry data attribute
        AvatarRenderer.initAvatars({
          selector: '.avatar-mini',
          configSource: function(canvas) {
            var entryEl = canvas.closest('.entry');
            if (!entryEl) return AvatarRenderer.loadFromStorage();
            
            // Try to get avatar_config from data attribute (from backend)
            var configAttr = entryEl.getAttribute('data-avatar-config');
            if (configAttr) {
              try {
                return JSON.parse(configAttr);
              } catch (e) {}
            }
            
            // Fall back to localStorage
            return AvatarRenderer.loadFromStorage();
          }
        });
      }

      // Revision history modal
      function showRevisionHistory(entryId) {
        var revisionModal = document.getElementById('revision-modal');
        var revisionList = document.getElementById('revision-list');
        var revisionClose = document.getElementById('revision-close');
        
        revisionList.innerHTML = '<div class="empty-state">Loading...</div>';
        revisionModal.style.display = 'flex';
        
        AuthState.apiRequest('/api/entries/' + entryId + '/revisions')
          .then(function(data) {
            console.log('[REVISIONS]', data);
            if (data.success && data.revisions && data.revisions.length > 0) {
              revisionList.innerHTML = data.revisions.map(function(rev) {
                var date = new Date(rev.editedAt);
                var dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                return '<div class="revision-item">' +
                  '<div class="revision-header">' +
                    '<span class="revision-number">Revision #' + rev.revisionNumber + '</span>' +
                    '<span class="revision-date">' + dateStr + '</span>' +
                    (rev.editedBy ? '<span class="revision-author">by ' + Utils.escapeHtml(rev.editedBy) + '</span>' : '') +
                  '</div>' +
                  '<div class="revision-content">' + Utils.escapeHtml(rev.content) + '</div>' +
                '</div>';
              }).join('');
            } else {
              revisionList.innerHTML = '<div class="empty-state">NO EDIT HISTORY FOUND</div>';
            }
          })
          .catch(function(err) {
            console.error('[REVISIONS ERROR]', err);
            revisionList.innerHTML = '<div class="empty-state">FAILED TO LOAD HISTORY</div>';
          });
        
        revisionClose.onclick = function() {
          revisionModal.style.display = 'none';
        };
        
        revisionModal.onclick = function(e) {
          if (e.target === revisionModal) {
            revisionModal.style.display = 'none';
          }
        };
      }

      // Edit modal
      function showEditModal(entryId, currentContent) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="edit-modal">
            <div class="edit-modal-title">EDIT ENTRY</div>
            <textarea class="edit-modal-textarea">${currentContent}</textarea>
            <div class="edit-modal-actions">
              <button class="cancel-btn" id="edit-cancel">CANCEL</button>
              <button class="reply-submit" id="edit-save">SAVE</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var textarea = overlay.querySelector('.edit-modal-textarea');
        var cancelBtn = overlay.querySelector('#edit-cancel');
        var saveBtn = overlay.querySelector('#edit-save');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        saveBtn.addEventListener('click', function() {
          var newContent = textarea.value.trim();
          if (!newContent) return;

          saveBtn.disabled = true;
          saveBtn.textContent = 'SAVING...';

          AuthState.apiRequest('/api/entries/' + entryId, {
            method: 'PUT',
            body: JSON.stringify({ content: newContent })
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('ENTRY UPDATED', 'info');
              overlay.remove();
              fetchThread(currentSignalId, currentPage).then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
            } else {
              Notify.show(data.message || data.error || 'UPDATE FAILED', 'error');
              saveBtn.disabled = false;
              saveBtn.textContent = 'SAVE';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            saveBtn.disabled = false;
            saveBtn.textContent = 'SAVE';
          });
        });
      }

      // Delete confirmation
      function showDeleteConfirm(entryId) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="confirm-modal">
            <div class="confirm-modal-text">DELETE THIS ENTRY?</div>
            <div class="confirm-modal-actions">
              <button class="cancel-btn" id="delete-cancel">CANCEL</button>
              <button class="confirm-delete-btn" id="delete-confirm">DELETE</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var cancelBtn = overlay.querySelector('#delete-cancel');
        var confirmBtn = overlay.querySelector('#delete-confirm');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        confirmBtn.addEventListener('click', function() {
          confirmBtn.disabled = true;
          confirmBtn.textContent = 'DELETING...';

          AuthState.apiRequest('/api/entries/' + entryId, {
            method: 'DELETE'
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('ENTRY DELETED', 'info');
              overlay.remove();
              fetchThread(currentSignalId, currentPage).then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
            } else {
              Notify.show(data.error || 'DELETE FAILED', 'error');
              confirmBtn.disabled = false;
              confirmBtn.textContent = 'DELETE';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'DELETE';
          });
        });
      }

      // Quote entry - prefill reply textarea with structured quote format
      function quoteEntry(alias, content) {
        var replyTextarea = document.getElementById('reply-content');
        // Truncate quoted content if too long
        var quotedContent = content.length > 200 ? content.substring(0, 200) + '...' : content;
        var quotedText = '@' + alias + ' said:\n> ' + quotedContent.split('\n').join('\n> ') + '\n\n';
        replyTextarea.value = quotedText + replyTextarea.value;
        replyTextarea.focus();
        replyTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }

      // Markdown toolbar handlers
      document.querySelectorAll('.md-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var textarea = document.getElementById('reply-content');
          var start = textarea.selectionStart;
          var end = textarea.selectionEnd;
          var text = textarea.value;
          var selected = text.substring(start, end);
          var replacement = '';
          var cursorOffset = 0;
          
          switch(btn.dataset.md) {
            case 'bold':
              replacement = '**' + (selected || 'text') + '**';
              cursorOffset = selected ? 0 : -2;
              break;
            case 'italic':
              replacement = '*' + (selected || 'text') + '*';
              cursorOffset = selected ? 0 : -1;
              break;
            case 'strike':
              replacement = '~~' + (selected || 'text') + '~~';
              cursorOffset = selected ? 0 : -2;
              break;
            case 'code':
              if (selected.indexOf('\n') !== -1) {
                replacement = '```\n' + (selected || 'code') + '\n```';
              } else {
                replacement = '`' + (selected || 'code') + '`';
              }
              cursorOffset = selected ? 0 : -1;
              break;
            case 'link':
              replacement = '[' + (selected || 'text') + '](url)';
              cursorOffset = -1;
              break;
            case 'quote':
              replacement = '> ' + (selected || 'quote');
              break;
            case 'list':
              replacement = '- ' + (selected || 'item');
              break;
            case 'h1':
              replacement = '## ' + (selected || 'heading');
              break;
            case 'image':
              document.getElementById('image-upload').click();
              return;
          }
          
          if (replacement) {
            textarea.value = text.substring(0, start) + replacement + text.substring(end);
            textarea.focus();
            var newPos = start + replacement.length + cursorOffset;
            textarea.setSelectionRange(newPos, newPos);
            updatePreview();
          }
        });
      });

      // Image upload handler
      document.getElementById('image-upload').addEventListener('change', function(e) {
        var file = e.target.files[0];
        if (!file) return;
        
        var formData = new FormData();
        formData.append('image', file);
        
        Notify.show('UPLOADING IMAGE...', 'info');
        
        fetch(AuthState.API_BASE + '/api/upload/image', {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer ' + AuthState.getToken()
          },
          body: formData
        })
        .then(function(res) { return res.json(); })
        .then(function(data) {
          if (data.success) {
            var textarea = document.getElementById('reply-content');
            var imageMarkdown = '![image](' + data.url + ')';
            var pos = textarea.selectionStart;
            var text = textarea.value;
            textarea.value = text.substring(0, pos) + imageMarkdown + text.substring(pos);
            textarea.focus();
            Notify.show('IMAGE UPLOADED', 'success');
            updatePreview();
          } else {
            Notify.show(data.message || 'UPLOAD FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show('UPLOAD FAILED', 'error');
        });
        
        // Reset file input
        e.target.value = '';
      });

      // Preview toggle
      var previewVisible = false;
      var previewToggle = document.getElementById('preview-toggle');
      var replyPreview = document.getElementById('reply-preview');
      var previewContent = document.getElementById('preview-content');
      var replyTextarea = document.getElementById('reply-content');

      previewToggle.addEventListener('click', function() {
        previewVisible = !previewVisible;
        if (previewVisible) {
          updatePreview();
          replyPreview.style.display = 'block';
          previewToggle.classList.add('active');
        } else {
          replyPreview.style.display = 'none';
          previewToggle.classList.remove('active');
        }
      });

      function updatePreview() {
        if (!previewVisible) return;
        var content = replyTextarea.value;
        // Simple markdown parsing for preview
        var html = content;
        html = html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
        html = html.replace(/`(.+?)`/g, '<code>$1</code>');
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
        html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
        html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
        html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
        html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%;">');
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
        html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');
        html = html.replace(/\n/g, '<br>');
        previewContent.innerHTML = html || '<em style="color:#555">Start typing to see preview...</em>';
      }

      replyTextarea.addEventListener('input', updatePreview);

      // Jump to first unread
      var jumpUnreadBtn = document.getElementById('jump-unread-btn');
      var firstUnreadId = null;

      function checkFirstUnread() {
        if (!currentSignalId) return;
        
        AuthState.apiRequest('/api/threads/' + currentSignalId + '/first-unread')
          .then(function(data) {
            if (data.success && data.hasUnread && data.firstUnreadId) {
              firstUnreadId = data.firstUnreadId;
              jumpUnreadBtn.classList.add('visible');
            } else {
              jumpUnreadBtn.classList.remove('visible');
            }
          })
          .catch(function() {});
      }

      jumpUnreadBtn.addEventListener('click', function() {
        if (firstUnreadId) {
          var entryEl = document.querySelector('[data-entry-id="' + firstUnreadId + '"]');
          if (entryEl) {
            entryEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            entryEl.classList.add('highlight-entry');
            setTimeout(function() { entryEl.classList.remove('highlight-entry'); }, 2000);
          }
        }
      });

      // Report modal
      function showReportModal(entryId) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="report-modal">
            <div class="report-modal-title">REPORT ENTRY</div>
            <div class="report-reasons">
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="spam"> SPAM
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="harassment"> HARASSMENT
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="inappropriate"> INAPPROPRIATE CONTENT
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="misinformation"> MISINFORMATION
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="other"> OTHER
              </label>
            </div>
            <textarea class="report-details-input" placeholder="Additional details (optional)..." rows="2" maxlength="500"></textarea>
            <div class="report-modal-actions">
              <button class="cancel-btn" id="report-cancel">CANCEL</button>
              <button class="report-submit-btn" id="report-submit">SUBMIT REPORT</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var cancelBtn = overlay.querySelector('#report-cancel');
        var submitBtn = overlay.querySelector('#report-submit');
        var detailsInput = overlay.querySelector('.report-details-input');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        submitBtn.addEventListener('click', function() {
          var selectedReason = overlay.querySelector('input[name="report-reason"]:checked');
          if (!selectedReason) {
            Notify.show('SELECT A REASON', 'error');
            return;
          }

          submitBtn.disabled = true;
          submitBtn.textContent = 'SUBMITTING...';

          AuthState.apiRequest('/api/reports', {
            method: 'POST',
            body: JSON.stringify({
              entry_id: entryId,
              reason: selectedReason.value,
              details: detailsInput.value.trim()
            })
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('REPORT SUBMITTED', 'info');
              overlay.remove();
            } else {
              Notify.show(data.error || 'REPORT FAILED', 'error');
              submitBtn.disabled = false;
              submitBtn.textContent = 'SUBMIT REPORT';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            submitBtn.disabled = false;
            submitBtn.textContent = 'SUBMIT REPORT';
          });
        });
      }

      // Handle vote on entry
      function handleVote(entryId, voteValue, btnEl) {
        var votesEl = btnEl.closest('.entry-votes');
        var scoreEl = votesEl.querySelector('.vote-score');
        var upBtn = votesEl.querySelector('.vote-up');
        var downBtn = votesEl.querySelector('.vote-down');
        
        // Determine if we're toggling off
        var currentVote = upBtn.classList.contains('voted') ? 1 : (downBtn.classList.contains('voted') ? -1 : 0);
        var newVote = (currentVote === voteValue) ? 0 : voteValue;
        
        btnEl.disabled = true;
        
        AuthState.apiRequest('/api/entries/' + entryId + '/vote', {
          method: 'POST',
          body: JSON.stringify({ vote: newVote })
        })
        .then(function(data) {
          if (data.success) {
            // Update score
            scoreEl.textContent = data.score;
            scoreEl.classList.remove('positive', 'negative');
            if (data.score > 0) scoreEl.classList.add('positive');
            else if (data.score < 0) scoreEl.classList.add('negative');
            
            // Update buttons
            upBtn.classList.remove('voted');
            downBtn.classList.remove('voted');
            if (data.userVote === 1) upBtn.classList.add('voted');
            else if (data.userVote === -1) downBtn.classList.add('voted');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'ERROR', 'error');
        })
        .finally(function() {
          btnEl.disabled = false;
        });
      }

      function applyFilters() {
        var filtered = allEntries.slice();
        
        // Search (client-side for current page)
        if (currentSearch) {
          var q = currentSearch.toLowerCase();
          filtered = filtered.filter(function(e) {
            return e.content.toLowerCase().indexOf(q) !== -1;
          });
        }
        
        // Sort
        if (currentSort === 'newest') {
          filtered.reverse();
        } else if (currentSort === 'oldest') {
          // default order is oldest first
        }
        
        renderEntries(filtered, allAvatarConfigs, currentPagination);
      }

      // Debounced search for better performance
      var debouncedSearch = Utils.debounce(function(value) {
        currentSearch = value;
        applyFilters();
      }, 200);
      
      searchInput.addEventListener('input', function() {
        debouncedSearch(this.value);
      });

      sortBtns.forEach(function(btn) {
        btn.addEventListener('click', function() {
          sortBtns.forEach(function(b) { b.classList.remove('active'); });
          btn.classList.add('active');
          currentSort = btn.dataset.sort;
          applyFilters();
        });
      });

      /**
       * Fetch thread data from API
       */
      function fetchThread(signalId, page) {
        page = page || 1;
        var url = '/api/thread/' + signalId + '?page=' + page;
        
        return AuthState.apiRequest(url)
          .then(function(data) {
            if (data.success && data.thread) {
              var params = new URLSearchParams(window.location.search);
              var roomId = data.thread.roomId || params.get('room') || 'room-001';
              var sigNum = signalId ? signalId.replace('sig-', '') : '000';
              data.thread.signalIndex = 'SIG.' + sigNum;
              data.thread.roomName = 'NODE.' + roomId.replace('room-', '');
              // Build avatarConfigs map from entries
              data.avatarConfigs = {};
              if (data.entries) {
                data.entries.forEach(function(entry) {
                  if (entry.avatarConfig) {
                    data.avatarConfigs[entry.id] = entry.avatarConfig;
                  }
                });
              }
            }
            return data;
          });
      }

      /**
       * Initialize page
       */
      function init() {
        var signalId = getSignalIdFromUrl();
        currentSignalId = signalId;

        if (!signalId) {
          threadTitleEl.textContent = 'SIGNAL NOT FOUND';
          renderEntries([], {}, null);
          return;
        }

        // Join thread presence if WebSocket is already connected
        if (ForumWS.isConnected()) {
          ForumWS.viewThread(signalId, currentUserAvatarConfig);
        }

        // Show skeleton loading
        entriesContainer.innerHTML = UIComponents.skeletonEntries(5);

        fetchThread(signalId, 1)
          .then(function(data) {
            if (data.success) {
              updateSignalMeta(data.thread);
              roomNameEl.textContent = data.thread.roomName || 'NODE.001';
              allEntries = data.entries || [];
              allAvatarConfigs = data.avatarConfigs || {};
              currentPagination = data.pagination || null;
              
              // Set OP user ID from first entry or thread data
              if (allEntries.length > 0 && allEntries[0].user_id) {
                opUserId = allEntries[0].user_id;
              } else if (data.thread.created_by) {
                opUserId = data.thread.created_by;
              }
              
              renderEntries(allEntries, allAvatarConfigs, currentPagination);
              
              // Check bookmark and subscription status
              checkBookmarkStatus(data.thread.id);
              checkSubscriptionStatus(data.thread.id);
              
              // Load poll if exists
              loadPoll(data.thread.id);
              
              // Check for first unread post
              checkFirstUnread();
              
              // Mark as read with last entry ID
              if (allEntries.length > 0) {
                var lastEntryId = allEntries[allEntries.length - 1].id;
                markThreadAsRead(data.thread.id, lastEntryId);
              }
            } else {
              threadTitleEl.textContent = 'ERROR: ' + (data.error || 'UNKNOWN');
              allEntries = [];
              allAvatarConfigs = {};
              currentPagination = null;
              renderEntries([], {}, null);
              Notify.show(data.error || 'FAILED TO LOAD SIGNAL', 'error');
            }
          })
          .catch(function(err) {
            threadTitleEl.textContent = 'CONNECTION ERROR';
            allEntries = [];
            allAvatarConfigs = {};
            currentPagination = null;
            renderEntries([], {}, null);
            Notify.show(err.message || 'CONNECTION ERROR', 'error');
          });
      }
      
      // Bookmark functionality
      var bookmarkBtn = document.getElementById('bookmark-btn');
      var currentThreadDbId = null;
      
      function checkBookmarkStatus(threadId) {
        currentThreadDbId = threadId;
        AuthState.apiRequest('/api/bookmarks/' + threadId + '/check')
          .then(function(data) {
            if (data.success && data.isBookmarked) {
              bookmarkBtn.textContent = '[SAVED]';
              bookmarkBtn.classList.add('bookmarked');
            } else {
              bookmarkBtn.textContent = '[SAVE]';
              bookmarkBtn.classList.remove('bookmarked');
            }
          });
      }
      
      bookmarkBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        bookmarkBtn.disabled = true;
        
        AuthState.apiRequest('/api/bookmarks/' + currentThreadDbId, { method: 'POST' })
          .then(function(data) {
            if (data.success) {
              if (data.action === 'added') {
                bookmarkBtn.textContent = '[SAVED]';
                bookmarkBtn.classList.add('bookmarked');
                Notify.show('THREAD SAVED', 'info');
              } else {
                bookmarkBtn.textContent = '[SAVE]';
                bookmarkBtn.classList.remove('bookmarked');
                Notify.show('BOOKMARK REMOVED', 'info');
              }
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
          })
          .finally(function() {
            bookmarkBtn.disabled = false;
          });
      });

      // Share button - copy link to clipboard
      var shareBtn = document.getElementById('share-btn');
      shareBtn.addEventListener('click', function() {
        var url = window.location.href;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(url).then(function() {
            shareBtn.textContent = '[COPIED!]';
            Notify.show('LINK COPIED TO CLIPBOARD', 'info');
            setTimeout(function() { shareBtn.textContent = '[SHARE]'; }, 2000);
          }).catch(function() {
            fallbackCopy(url);
          });
        } else {
          fallbackCopy(url);
        }
      });
      
      function fallbackCopy(text) {
        var textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          shareBtn.textContent = '[COPIED!]';
          Notify.show('LINK COPIED TO CLIPBOARD', 'info');
          setTimeout(function() { shareBtn.textContent = '[SHARE]'; }, 2000);
        } catch (e) {
          Notify.show('FAILED TO COPY', 'error');
        }
        document.body.removeChild(textarea);
      }

      // Subscribe functionality
      var subscribeBtn = document.getElementById('subscribe-btn');
      var isSubscribed = false;

      function checkSubscriptionStatus(threadId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/subscribe')
          .then(function(data) {
            if (data.success) {
              isSubscribed = data.subscribed;
              updateSubscribeButton();
            }
          });
      }

      function updateSubscribeButton() {
        if (isSubscribed) {
          subscribeBtn.textContent = '[WATCHING]';
          subscribeBtn.classList.add('subscribed');
        } else {
          subscribeBtn.textContent = '[WATCH]';
          subscribeBtn.classList.remove('subscribed');
        }
      }

      subscribeBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        subscribeBtn.disabled = true;
        
        var method = isSubscribed ? 'DELETE' : 'POST';
        AuthState.apiRequest('/api/threads/' + currentThreadDbId + '/subscribe', { method: method })
          .then(function(data) {
            if (data.success) {
              isSubscribed = data.subscribed;
              updateSubscribeButton();
              Notify.show(isSubscribed ? 'SUBSCRIBED' : 'UNSUBSCRIBED', 'info');
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
          })
          .finally(function() {
            subscribeBtn.disabled = false;
          });
      });

      // Mark thread as read when viewing
      function markThreadAsRead(threadId, lastEntryId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/read', {
          method: 'POST',
          body: JSON.stringify({ last_entry_id: lastEntryId })
        });
      }

      // Poll functionality
      var pollContainer = document.getElementById('poll-container');
      var pollQuestion = document.getElementById('poll-question');
      var pollMeta = document.getElementById('poll-meta');
      var pollOptions = document.getElementById('poll-options');
      var pollVoteBtn = document.getElementById('poll-vote-btn');
      var pollTotal = document.getElementById('poll-total');
      var currentPoll = null;
      var selectedOptions = [];

      function loadPoll(threadId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/poll')
          .then(function(data) {
            if (data.success && data.poll) {
              currentPoll = data.poll;
              renderPoll(data.poll);
            }
          });
      }

      function renderPoll(poll) {
        pollContainer.style.display = 'block';
        pollQuestion.textContent = poll.question;
        
        var metaText = 'Created by ' + poll.createdBy;
        var expiryClass = '';
        if (poll.endsAt) {
          var endsAt = new Date(poll.endsAt);
          var now = new Date();
          var hoursLeft = (endsAt - now) / (1000 * 60 * 60);
          
          if (poll.isExpired) {
            metaText += ' ‚Ä¢ <span class="poll-expiry expired">EXPIRED</span>';
          } else if (hoursLeft < 24) {
            metaText += ' ‚Ä¢ <span class="poll-expiry ending-soon">Ends in ' + Math.ceil(hoursLeft) + 'h</span>';
          } else {
            metaText += ' ‚Ä¢ Ends: ' + endsAt.toLocaleDateString();
          }
        }
        if (poll.allowMultiple) {
          metaText += ' ‚Ä¢ Multiple choice';
        }
        pollMeta.innerHTML = metaText;

        var hasVoted = poll.userVotes && poll.userVotes.length > 0;
        selectedOptions = poll.userVotes ? poll.userVotes.slice() : [];

        pollOptions.innerHTML = poll.options.map(function(opt) {
          var isSelected = selectedOptions.includes(opt.id);
          var votedClass = hasVoted || poll.isExpired ? 'voted' : '';
          var selectedClass = isSelected ? 'selected' : '';
          
          var barWidth = hasVoted || poll.isExpired ? opt.percentage : 0;
          
          return '<div class="poll-option-wrapper">' +
            '<div class="poll-option-bar" style="width: ' + barWidth + '%;"></div>' +
            '<label class="poll-option ' + votedClass + ' ' + selectedClass + '" data-option-id="' + opt.id + '">' +
              (hasVoted || poll.isExpired ? '' : '<input type="' + (poll.allowMultiple ? 'checkbox' : 'radio') + '" name="poll-option" value="' + opt.id + '" ' + (isSelected ? 'checked' : '') + '>') +
              '<span class="poll-option-text">' + escapeHtml(opt.text) + '</span>' +
              '<span class="poll-option-stats">' + opt.voteCount + ' (' + opt.percentage + '%)</span>' +
            '</label>' +
          '</div>';
        }).join('');

        pollTotal.textContent = poll.totalVoters + ' total voter' + (poll.totalVoters !== 1 ? 's' : '');

        // Show vote button if not voted and not expired
        if (!hasVoted && !poll.isExpired) {
          pollVoteBtn.style.display = 'inline-block';
          pollVoteBtn.disabled = true;

          // Bind option selection
          pollOptions.querySelectorAll('input').forEach(function(input) {
            input.addEventListener('change', function() {
              if (currentPoll.allowMultiple) {
                if (this.checked) {
                  selectedOptions.push(parseInt(this.value));
                } else {
                  selectedOptions = selectedOptions.filter(function(id) { return id !== parseInt(input.value); });
                }
              } else {
                selectedOptions = [parseInt(this.value)];
              }
              pollVoteBtn.disabled = selectedOptions.length === 0;
              
              // Update selected styling
              pollOptions.querySelectorAll('.poll-option').forEach(function(opt) {
                var optId = parseInt(opt.dataset.optionId);
                if (selectedOptions.includes(optId)) {
                  opt.classList.add('selected');
                } else {
                  opt.classList.remove('selected');
                }
              });
            });
          });
        } else {
          pollVoteBtn.style.display = 'none';
        }
      }

      function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      pollVoteBtn.addEventListener('click', function() {
        if (!currentPoll || selectedOptions.length === 0) return;
        pollVoteBtn.disabled = true;
        pollVoteBtn.textContent = 'VOTING...';

        AuthState.apiRequest('/api/polls/' + currentPoll.id + '/vote', {
          method: 'POST',
          body: JSON.stringify({ optionIds: selectedOptions })
        })
        .then(function(data) {
          if (data.success) {
            Notify.show('VOTE RECORDED', 'info');
            loadPoll(currentThreadDbId);
          } else {
            Notify.show(data.error || 'VOTE FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'VOTE ERROR', 'error');
        })
        .finally(function() {
          pollVoteBtn.textContent = 'VOTE';
          pollVoteBtn.disabled = false;
        });
      });

      // Reply form handler
      var replyForm = document.getElementById('reply-form');
      var replyContent = document.getElementById('reply-content');
      var draftIndicator = document.createElement('span');
      draftIndicator.className = 'draft-indicator';
      draftIndicator.textContent = 'Draft saved';
      draftIndicator.style.display = 'none';
      replyForm.querySelector('.reply-submit').parentNode.insertBefore(draftIndicator, replyForm.querySelector('.reply-submit'));
      
      // Initialize @mentions autocomplete
      Utils.initMentions(replyContent, AuthState.apiRequest);
      
      // Draft auto-save with debounce
      var draftKey = 'thread_' + getSignalIdFromUrl();
      var savedDraft = Utils.drafts.get(draftKey);
      if (savedDraft) {
        replyContent.value = savedDraft;
        draftIndicator.style.display = 'inline';
      }
      
      var saveDraft = Utils.debounce(function(content) {
        if (content.trim()) {
          Utils.drafts.set(draftKey, content);
          draftIndicator.style.display = 'inline';
          draftIndicator.classList.add('pulse');
          setTimeout(function() { draftIndicator.classList.remove('pulse'); }, 500);
        } else {
          Utils.drafts.remove(draftKey);
          draftIndicator.style.display = 'none';
        }
      }, 1000);
      
      // Typing indicator - debounced to avoid spam
      var isTyping = false;
      var typingTimeout = null;
      var sendTypingIndicator = Utils.debounce(function() {
        if (currentSignalId && ForumWS.isConnected()) {
          ForumWS.sendTyping(currentSignalId);
          isTyping = true;
          
          // Clear typing after 3 seconds of no input
          if (typingTimeout) clearTimeout(typingTimeout);
          typingTimeout = setTimeout(function() {
            if (currentSignalId && ForumWS.isConnected()) {
              ForumWS.sendStopTyping(currentSignalId);
              isTyping = false;
            }
          }, 3000);
        }
      }, 300);
      
      replyContent.addEventListener('input', function() {
        saveDraft(this.value);
        
        // Send typing indicator
        if (this.value.trim().length > 0) {
          sendTypingIndicator();
        } else if (isTyping) {
          // Cleared the input, stop typing
          if (typingTimeout) clearTimeout(typingTimeout);
          if (currentSignalId && ForumWS.isConnected()) {
            ForumWS.sendStopTyping(currentSignalId);
            isTyping = false;
          }
        }
      });
      
      // Stop typing on blur
      replyContent.addEventListener('blur', function() {
        if (isTyping && currentSignalId && ForumWS.isConnected()) {
          ForumWS.sendStopTyping(currentSignalId);
          isTyping = false;
          if (typingTimeout) clearTimeout(typingTimeout);
        }
      });
      
      // Ghost mode toggle
      var ghostModeToggle = document.getElementById('ghost-mode-toggle');
      var ghostToggleContainer = document.getElementById('ghost-toggle-container');
      
      ghostModeToggle.addEventListener('change', function() {
        if (this.checked) {
          ghostToggleContainer.classList.add('active');
          replyContent.placeholder = 'ANONYMOUS POST ‚Äî Identity will not be displayed.';
        } else {
          ghostToggleContainer.classList.remove('active');
          replyContent.placeholder = 'ENTER YOUR RESPONSE... (Markdown supported: **bold**, *italic*, `code`, > quote)';
        }
      });
      
      // Vault mode toggle
      var vaultModeToggle = document.getElementById('vault-mode-toggle');
      var vaultToggleContainer = vaultModeToggle.parentElement;
      var vaultLevelSelect = document.getElementById('vault-level');
      
      vaultModeToggle.addEventListener('change', function() {
        if (this.checked) {
          vaultToggleContainer.classList.add('active');
          vaultLevelSelect.disabled = false;
          vaultLevelSelect.value = '10'; // Default to 10+ rep
        } else {
          vaultToggleContainer.classList.remove('active');
          vaultLevelSelect.disabled = true;
          vaultLevelSelect.value = '';
        }
      });
      
      replyForm.addEventListener('submit', function(e) {
        e.preventDefault();
        var content = replyContent.value.trim();
        if (!content) return;
        
        // Get vault level
        var vaultLevel = vaultModeToggle.checked ? vaultLevelSelect.value : null;
        
        // Stop typing indicator on submit
        if (isTyping && currentSignalId && ForumWS.isConnected()) {
          ForumWS.sendStopTyping(currentSignalId);
          isTyping = false;
          if (typingTimeout) clearTimeout(typingTimeout);
        }
        
        var submitBtn = replyForm.querySelector('.reply-submit');
        var isGhostMode = ghostModeToggle.checked;
        submitBtn.disabled = true;
        submitBtn.textContent = isGhostMode ? 'POSTING...' : 'TRANSMITTING...';
        
        AuthState.apiRequest('/api/entries', {
          method: 'POST',
          body: JSON.stringify({
            threadId: parseInt(currentSignalId),
            content: content,
            isGhost: isGhostMode,
            vaultLevel: vaultLevel
          })
        })
        .then(function(data) {
          if (data.success) {
            replyContent.value = '';
            Utils.drafts.remove(draftKey);
            draftIndicator.style.display = 'none';
            ghostModeToggle.checked = false;
            ghostToggleContainer.classList.remove('active');
            vaultModeToggle.checked = false;
            vaultToggleContainer.classList.remove('active');
            vaultLevelSelect.disabled = true;
            vaultLevelSelect.value = '';
            replyContent.placeholder = 'ENTER YOUR RESPONSE... (Markdown supported: **bold**, *italic*, `code`, > quote)';
            Notify.show(isGhostMode ? 'ANONYMOUS ENTRY RECORDED' : 'ENTRY RECORDED', 'info');
            // Reload entries
            fetchThread(currentSignalId, currentPage)
              .then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  allAvatarConfigs = data.avatarConfigs || {};
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
          } else {
            Notify.show(data.error || 'TRANSMISSION FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'CONNECTION ERROR', 'error');
        })
        .finally(function() {
          submitBtn.disabled = false;
          submitBtn.textContent = 'TRANSMIT';
        });
      });

      // Admin controls for pin/lock
      var pinBtn = document.getElementById('pin-btn');
      var lockBtn = document.getElementById('lock-btn');

      pinBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        pinBtn.disabled = true;
        
        AuthState.apiRequest('/api/admin/threads/' + currentThreadDbId + '/pin', { method: 'PUT' })
          .then(function(data) {
            if (data.success) {
              currentThreadData.isPinned = data.is_pinned;
              updateThreadBadges(currentThreadData);
              updateAdminControls(currentThreadData);
              Notify.show(data.is_pinned ? 'THREAD PINNED' : 'THREAD UNPINNED', 'info');
            }
          })
          .catch(function(err) {
            Notify.show('ERROR', 'error');
          })
          .finally(function() {
            pinBtn.disabled = false;
          });
      });

      lockBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        lockBtn.disabled = true;
        
        AuthState.apiRequest('/api/admin/threads/' + currentThreadDbId + '/lock', { method: 'PUT' })
          .then(function(data) {
            if (data.success) {
              currentThreadData.isLocked = data.is_locked;
              updateThreadBadges(currentThreadData);
              updateAdminControls(currentThreadData);
              Notify.show(data.is_locked ? 'THREAD LOCKED' : 'THREAD UNLOCKED', 'info');
              // Update reply form visibility
              updateReplyFormForLock(data.is_locked);
            }
          })
          .catch(function(err) {
            Notify.show('ERROR', 'error');
          })
          .finally(function() {
            lockBtn.disabled = false;
          });
      });

      function updateReplyFormForLock(isLocked) {
        var replyFormContainer = document.querySelector('.reply-form-container');
        if (isLocked && !AuthState.isAdmin()) {
          replyFormContainer.innerHTML = '<div class="locked-notice">üîí THIS THREAD IS LOCKED</div>';
        }
      }

      // Back to top button
      var backToTopBtn = document.getElementById('back-to-top');
      
      window.addEventListener('scroll', function() {
        if (window.scrollY > 300) {
          backToTopBtn.classList.add('visible');
        } else {
          backToTopBtn.classList.remove('visible');
        }
      });
      
      backToTopBtn.addEventListener('click', function() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // 'r' - Focus reply textarea
        if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          replyContent.focus();
        }
        
        // 'g' then 't' - Go to top
        if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // 'g' then 'b' - Go to bottom
        if (e.key === 'b' && !e.ctrlKey && !e.metaKey) {
          window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
        
        // 'j' - Scroll down
        if (e.key === 'j' && !e.ctrlKey && !e.metaKey) {
          window.scrollBy({ top: 100, behavior: 'smooth' });
        }
        
        // 'k' - Scroll up
        if (e.key === 'k' && !e.ctrlKey && !e.metaKey) {
          window.scrollBy({ top: -100, behavior: 'smooth' });
        }
        
        // '[' - Previous page
        if (e.key === '[' && currentPagination && currentPage > 1) {
          currentPage--;
          fetchThread(currentSignalId, currentPage);
        }
        
        // ']' - Next page
        if (e.key === ']' && currentPagination && currentPage < currentPagination.totalPages) {
          currentPage++;
          fetchThread(currentSignalId, currentPage);
        }
        
        // '?' - Show keyboard shortcuts modal
        if (e.key === '?' && e.shiftKey) {
          e.preventDefault();
          shortcutsOverlay.classList.add('active');
        }
        
        // Escape - Close shortcuts modal
        if (e.key === 'Escape') {
          shortcutsOverlay.classList.remove('active');
        }
      });
      
      // Theme toggle initialization
      Utils.initTheme();
      
      // Keyboard shortcuts modal
      var shortcutsOverlay = document.getElementById('shortcuts-modal');
      var shortcutsClose = shortcutsOverlay.querySelector('.shortcuts-close');
      
      shortcutsClose.addEventListener('click', function() {
        shortcutsOverlay.classList.remove('active');
      });
      
      shortcutsOverlay.addEventListener('click', function(e) {
        if (e.target === shortcutsOverlay) {
          shortcutsOverlay.classList.remove('active');
        }
      });
      
      // Scroll progress bar
      var scrollProgress = document.getElementById('scroll-progress');
      var updateScrollProgress = Utils.throttle(function() {
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        var docHeight = document.documentElement.scrollHeight - window.innerHeight;
        var progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
        scrollProgress.style.width = progress + '%';
      }, 16);
      
      window.addEventListener('scroll', updateScrollProgress, { passive: true });
      
      // ===== Polling for New Entries =====
      var pollInterval = null;
      var POLL_DELAY = 30000; // 30 seconds
      var lastEntryId = 0;
      
      function startPolling() {
        if (pollInterval) return;
        
        pollInterval = setInterval(function() {
          // Only poll if tab is visible and we have entries
          if (document.hidden || !currentSignalId || allEntries.length === 0) return;
          
          // Get the latest entry ID we have
          var latestId = Math.max.apply(null, allEntries.map(function(e) { return e.id; }));
          
          // Check for new entries
          AuthState.apiRequest('/api/thread/' + currentSignalId + '?after=' + latestId)
            .then(function(data) {
              if (data.success && data.entries && data.entries.length > 0) {
                // Filter to only truly new entries
                var newEntries = data.entries.filter(function(entry) {
                  return !allEntries.some(function(e) { return e.id === entry.id; });
                });
                
                if (newEntries.length > 0) {
                  // Add new entries to our array
                  newEntries.forEach(function(entry) {
                    allEntries.push(entry);
                  });
                  
                  // Append new entries to DOM
                  var emptyState = entriesContainer.querySelector('.empty-state');
                  if (emptyState) emptyState.remove();
                  
                  newEntries.forEach(function(entry) {
                    var tempDiv = document.createElement('div');
                    tempDiv.innerHTML = UIComponents.entryElement(entry, currentUserId, opUserId);
                    var newEntryEl = tempDiv.firstElementChild;
                    newEntryEl.style.borderLeft = '3px solid var(--success, #4caf50)';
                    newEntryEl.style.animation = 'fadeIn 0.3s ease-out';
                    entriesContainer.appendChild(newEntryEl);
                    
                    // Bind events for new entry
                    bindNewEntryEvents(newEntryEl);
                    
                    // Initialize avatar
                    var canvas = newEntryEl.querySelector('.avatar-mini');
                    if (canvas) {
                      var configAttr = newEntryEl.getAttribute('data-avatar-config');
                      if (configAttr) {
                        try {
                          AvatarRenderer.render(canvas, JSON.parse(configAttr));
                        } catch (e) {}
                      }
                    }
                  });
                  
                  // Update count
                  entryCountEl.textContent = allEntries.length;
                  
                  // Notify user if not at bottom
                  var isAtBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 200;
                  if (!isAtBottom) {
                    Notify.show(newEntries.length + ' NEW ' + (newEntries.length === 1 ? 'ENTRY' : 'ENTRIES'), 'info');
                  }
                }
              }
            })
            .catch(function() {
              // Silent fail - don't spam errors
            });
        }, POLL_DELAY);
      }
      
      function stopPolling() {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
      }
      
      // Helper to bind events on new entries from polling
      function bindNewEntryEvents(entryEl) {
        var editBtn = entryEl.querySelector('.entry-edit-btn');
        if (editBtn) {
          editBtn.addEventListener('click', function() {
            var entryId = editBtn.dataset.entryId;
            var content = entryEl.querySelector('.entry-content p').textContent;
            showEditModal(entryId, content);
          });
        }
        
        var deleteBtn = entryEl.querySelector('.entry-delete-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', function() {
            showDeleteConfirm(deleteBtn.dataset.entryId);
          });
        }
        
        var quoteBtn = entryEl.querySelector('.entry-quote-btn');
        if (quoteBtn) {
          quoteBtn.addEventListener('click', function() {
            quoteEntry(quoteBtn.dataset.alias, entryEl.querySelector('.entry-content p').textContent);
          });
        }
        
        var reportBtn = entryEl.querySelector('.entry-report-btn');
        if (reportBtn) {
          reportBtn.addEventListener('click', function() {
            showReportModal(reportBtn.dataset.entryId);
          });
        }
        
        entryEl.querySelectorAll('.reaction-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var reactionsEl = btn.closest('.entry-reactions');
            toggleReaction(reactionsEl.dataset.entryId, btn.dataset.reaction, btn);
          });
        });
      }
      
      // Start polling when page loads, stop when leaving
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          stopPolling();
        } else {
          startPolling();
        }
      });
      
      // Start polling after initial load
      setTimeout(startPolling, 2000);
      
      // Fetch online user count
      var onlineCountEl = document.getElementById('online-count');
      function fetchOnlineCount() {
        AuthState.apiRequest('/api/users/online')
          .then(function(data) {
            if (data.success) {
              onlineCountEl.textContent = data.users.length + ' ONLINE';
            }
          })
          .catch(function() {});
      }
      fetchOnlineCount();
      setInterval(fetchOnlineCount, 60000); // Update every minute

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      document.querySelector('[data-action="logout"]').addEventListener('click', function(e) {
        e.preventDefault();
        AuthState.logout();
      });
    })();
  </script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASPD Forum ‚Äî Thread</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>

  <!-- Skip to main content -->
  <a href="#entries-container" class="skip-link">Skip to thread entries</a>

  <!-- Noise Overlay -->
  <div class="noise" aria-hidden="true"></div>

  <!-- Thread Layout -->
  <div class="thread-container" data-page="thread" data-signal-id="">

    <!-- Header -->
    <header class="thread-header" data-component="thread-header" role="banner">
      <nav class="thread-header-left" aria-label="Breadcrumb">
        <a href="room.html" class="thread-back" data-bind="back-link" aria-label="Back to room">‚Üê INDEX</a>
        <span class="thread-divider" aria-hidden="true">/</span>
        <span class="thread-room" data-bind="room-name">NODE.000</span>
      </nav>
      <nav class="header-right" aria-label="User navigation">
        <span class="thread-entry-count" data-bind="entry-count" aria-live="polite"><span id="entry-count">0</span> RECORDS</span>
        <a href="#" class="header-notifications" id="notif-bell" title="Notifications" aria-label="View notifications" role="button">
          <span class="notif-icon" aria-hidden="true">[!]</span>
          <span class="notif-badge" id="notif-badge" style="display: none;" aria-live="polite">0</span>
        </a>
        <a href="profile.html" class="header-profile" aria-label="View profile">PROFILE</a>
        <a href="messages.html" class="header-messages" aria-label="Messages">MSG</a>
        <a href="#" class="header-exit" data-action="logout" aria-label="Sign out">EXIT</a>
      </nav>
    </header>

    <!-- Thread Title -->
    <div class="thread-title-bar" role="heading" aria-level="1">
      <h1 class="thread-title" data-bind="thread-title">Loading...</h1>
      <span class="thread-status-badges" id="thread-badges" aria-live="polite"></span>
      <button class="subscribe-btn" id="subscribe-btn" title="Subscribe to thread" aria-label="Subscribe to this thread" aria-pressed="false">[WATCH]</button>
      <button class="bookmark-btn" id="bookmark-btn" title="Bookmark this thread" aria-label="Bookmark this thread" aria-pressed="false">[SAVE]</button>
      <span class="thread-slow-mode" id="slow-mode-indicator" style="display: none;" role="status" aria-live="polite"></span>
      <!-- Admin Controls -->
      <div class="thread-admin-controls" id="thread-admin-controls" style="display: none;" role="group" aria-label="Admin controls">
        <button class="admin-btn" id="pin-btn" title="Pin/Unpin thread" aria-label="Pin or unpin thread" aria-pressed="false">[PIN]</button>
        <button class="admin-btn" id="lock-btn" title="Lock/Unlock thread" aria-label="Lock or unlock thread" aria-pressed="false">[LOCK]</button>
      </div>
    </div>

    <!-- Filter Bar -->
    <div class="filter-bar" role="search">
      <label for="search-input" class="sr-only">Search entries in this thread</label>
      <input type="text" id="search-input" class="filter-input" placeholder="SEARCH ENTRIES..." aria-label="Search entries">
      <div class="sort-controls" role="group" aria-label="Sort options">
        <button class="sort-btn active" data-sort="default" aria-pressed="true">DEFAULT</button>
        <button class="sort-btn" data-sort="newest" aria-pressed="false">NEWEST</button>
        <button class="sort-btn" data-sort="oldest" aria-pressed="false">OLDEST</button>
      </div>
    </div>

    <!-- Poll Container (if thread has a poll) -->
    <section class="poll-container" id="poll-container" style="display: none;" aria-label="Thread poll">
      <h2 class="poll-question" id="poll-question"></h2>
      <div class="poll-meta" id="poll-meta" aria-live="polite"></div>
      <div class="poll-options" id="poll-options" role="group" aria-label="Poll options"></div>
      <button class="poll-vote-btn" id="poll-vote-btn" style="display: none;" aria-label="Submit your vote">VOTE</button>
      <div class="poll-total" id="poll-total" aria-live="polite"></div>
    </section>

    <!-- Entry List - Container for dynamic entries -->
    <main class="entry-list" id="entries-container" data-container="entries" role="main" aria-label="Thread entries">
      <!-- PLACEHOLDER: Entry elements will be injected here by JS -->
    </main>

    <!-- Pagination -->
    <div id="pagination-container"></div>

    <!-- Reply Form -->
    <section class="reply-form-container" id="reply-form-container" aria-label="Reply to thread">
      <form id="reply-form" class="reply-form" aria-label="Post a reply">
        <!-- Markdown Toolbar -->
        <div class="markdown-toolbar" role="toolbar" aria-label="Text formatting">
          <button type="button" class="md-btn" data-md="bold" title="Bold (**text**)" aria-label="Bold"><strong>B</strong></button>
          <button type="button" class="md-btn" data-md="italic" title="Italic (*text*)" aria-label="Italic"><em>I</em></button>
          <button type="button" class="md-btn" data-md="strike" title="Strikethrough (~~text~~)" aria-label="Strikethrough"><del>S</del></button>
          <button type="button" class="md-btn" data-md="code" title="Code (`code`)" aria-label="Code">&lt;/&gt;</button>
          <button type="button" class="md-btn" data-md="link" title="Link ([text](url))" aria-label="Insert link">üîó</button>
          <button type="button" class="md-btn" data-md="quote" title="Quote (> text)" aria-label="Quote">&gt;</button>
          <button type="button" class="md-btn" data-md="list" title="List (- item)" aria-label="List">‚ò∞</button>
          <button type="button" class="md-btn" data-md="h1" title="Heading (#)" aria-label="Heading">H</button>
          <span class="markdown-help" aria-hidden="true">MARKDOWN SUPPORTED</span>
        </div>
        <label for="reply-content" class="sr-only">Your reply</label>
        <textarea id="reply-content" class="reply-textarea" placeholder="ENTER YOUR RESPONSE... (Markdown supported: **bold**, *italic*, `code`, > quote)" rows="3" required aria-label="Write your reply"></textarea>
        <button type="submit" class="reply-submit" aria-label="Submit reply">TRANSMIT</button>
      </form>
    </section>

    <!-- Jump to Unread Button -->
    <button class="jump-unread-btn" id="jump-unread-btn" title="Jump to first unread" aria-label="Jump to first unread post">‚Üì NEW</button>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="back-to-top" title="Back to top" aria-label="Scroll to top of page">‚Üë TOP</button>

    <!-- Footer -->
    <footer class="thread-footer" data-component="thread-footer" role="contentinfo">
      <span data-bind="signal-id">SIG.000</span>
      <span aria-hidden="true">RECORD VIEW</span>
      <span data-bind="connection-status" aria-live="polite">CONN.ACTIVE</span>
    </footer>

  </div>

  <!-- Theme Toggle -->
  <button class="theme-toggle" id="theme-toggle" aria-label="Switch to light mode" aria-pressed="false" title="Toggle theme">‚òÄÔ∏è</button>

  <!-- Keyboard Shortcuts Modal -->
  <div class="shortcuts-modal-overlay" id="shortcuts-modal" role="dialog" aria-modal="true" aria-labelledby="shortcuts-title">
    <div class="shortcuts-modal">
      <h2 class="shortcuts-title" id="shortcuts-title">KEYBOARD SHORTCUTS</h2>
      <div class="shortcuts-section">
        <h3 class="shortcuts-section-title">Navigation</h3>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">?</span></span><span class="shortcut-desc">Show this help</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">g</span><span class="shortcut-key">h</span></span><span class="shortcut-desc">Go to home</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">/</span></span><span class="shortcut-desc">Focus search</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">Esc</span></span><span class="shortcut-desc">Close modal</span></div>
      </div>
      <div class="shortcuts-section">
        <h3 class="shortcuts-section-title">Thread View</h3>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">r</span></span><span class="shortcut-desc">Focus reply</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">j</span></span><span class="shortcut-desc">Next entry</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">k</span></span><span class="shortcut-desc">Previous entry</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">t</span></span><span class="shortcut-desc">Go to top</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">b</span></span><span class="shortcut-desc">Go to bottom</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">[</span></span><span class="shortcut-desc">Previous page</span></div>
        <div class="shortcut-row"><span class="shortcut-keys"><span class="shortcut-key">]</span></span><span class="shortcut-desc">Next page</span></div>
      </div>
      <button class="shortcuts-close" id="shortcuts-close">CLOSE [ESC]</button>
    </div>
  </div>

  <!-- Scroll Progress -->
  <div class="scroll-progress" id="scroll-progress"></div>

  <script src="js/utils.js"></script>
  <script src="js/auth-state.js"></script>
  <script src="js/notify.js"></script>
  <script src="js/notifications.js"></script>
  <script src="js/avatar-renderer.js"></script>
  <script src="js/ui-components.js"></script>
  <script src="js/ws-manager.js"></script>
  <script>
    (function() {
      'use strict';

      Notify.checkUrlNotify();

      if (!AuthState.gateProtected()) return;

      var entriesContainer = document.getElementById('entries-container');
      var paginationContainer = document.getElementById('pagination-container');
      var entryCountEl = document.getElementById('entry-count');
      var slowModeIndicator = document.getElementById('slow-mode-indicator');
      var threadContainer = document.querySelector('[data-page="thread"]');
      var threadTitleEl = document.querySelector('[data-bind="thread-title"]');
      var roomNameEl = document.querySelector('[data-bind="room-name"]');
      var signalIdEl = document.querySelector('[data-bind="signal-id"]');
      var backLinkEl = document.querySelector('[data-bind="back-link"]');
      var searchInput = document.getElementById('search-input');
      var sortBtns = document.querySelectorAll('.sort-btn');

      var allEntries = [];
      var allAvatarConfigs = {};
      var currentSort = 'default';
      var currentSearch = '';
      var currentPage = 1;
      var currentPagination = null;
      var currentSignalId = null;
      
      // Get current user ID from JWT token
      var currentUserId = null;
      try {
        var token = AuthState.getToken();
        if (token) {
          var payload = JSON.parse(atob(token.split('.')[1]));
          currentUserId = payload.userId;
        }
      } catch (e) {}
      var currentPagination = null;
      var currentSignalId = null;

      function getSignalIdFromUrl() {
        var params = new URLSearchParams(window.location.search);
        return params.get('id');
      }

      function updateSlowModeIndicator(interval) {
        if (interval && interval > 0) {
          slowModeIndicator.textContent = 'SLOW MODE: ' + interval + 's';
          slowModeIndicator.style.display = 'inline';
        } else {
          slowModeIndicator.style.display = 'none';
        }
      }

      function updateSignalMeta(signalMeta) {
        if (!signalMeta) return;
        var signalId = signalMeta.id || '';
        var signalIndex = signalMeta.signalIndex || 'SIG.000';
        var roomId = signalMeta.roomId || '';
        threadContainer.setAttribute('data-signal-id', signalId);
        threadTitleEl.textContent = signalMeta.title || 'Untitled';
        signalIdEl.textContent = signalIndex;
        if (roomId) {
          backLinkEl.href = 'room.html?id=' + roomId;
        }
        document.title = 'ASPD Forum ‚Äî ' + (signalMeta.title || 'Thread');
        updateSlowModeIndicator(signalMeta.slowModeInterval);
        updateThreadBadges(signalMeta);
        updateAdminControls(signalMeta);
      }

      function updateThreadBadges(threadData) {
        var badgesEl = document.getElementById('thread-badges');
        var badges = [];
        if (threadData.isPinned) badges.push('<span class="thread-badge pinned">üìå PINNED</span>');
        if (threadData.isLocked) badges.push('<span class="thread-badge locked">üîí LOCKED</span>');
        badgesEl.innerHTML = badges.join(' ');
      }

      var currentThreadData = null;

      function updateAdminControls(threadData) {
        currentThreadData = threadData;
        if (!AuthState.isAdmin()) return;
        
        var adminControls = document.getElementById('thread-admin-controls');
        var pinBtn = document.getElementById('pin-btn');
        var lockBtn = document.getElementById('lock-btn');
        
        adminControls.style.display = 'flex';
        pinBtn.textContent = threadData.isPinned ? '[UNPIN]' : '[PIN]';
        lockBtn.textContent = threadData.isLocked ? '[UNLOCK]' : '[LOCK]';
      }

      /**
       * Render entries to the list
       * @param {Array} entries - Array of entry objects
       * @param {Object} avatarConfigs - Map of userId to avatar config (from backend)
       * @param {Object} pagination - Pagination info
       */
      function renderEntries(entries, avatarConfigs, pagination) {
        avatarConfigs = avatarConfigs || {};
        if (!entries || !entries.length) {
          entriesContainer.innerHTML = '<div class="empty-state" data-empty="entries">NO RECORDS AVAILABLE</div>';
          entryCountEl.textContent = '0';
          paginationContainer.innerHTML = '';
          return;
        }
        entriesContainer.innerHTML = entries.map(function(entry) {
          return UIComponents.entryElement(entry, currentUserId);
        }).join('');
        entryCountEl.textContent = pagination ? pagination.total : entries.length;

        // Render pagination
        paginationContainer.innerHTML = UIComponents.paginationControls(pagination);
        
        // Bind pagination events
        paginationContainer.querySelectorAll('.pagination-btn:not(.pagination-go-btn)').forEach(function(btn) {
          btn.addEventListener('click', function() {
            if (btn.disabled) return;
            currentPage = parseInt(btn.dataset.page);
            fetchThread(currentSignalId, currentPage);
          });
        });
        
        // Bind pagination jump events
        var jumpInput = paginationContainer.querySelector('.pagination-jump-input');
        var goBtn = paginationContainer.querySelector('.pagination-go-btn');
        if (jumpInput && goBtn) {
          goBtn.addEventListener('click', function() {
            var pageNum = parseInt(jumpInput.value);
            if (pageNum >= 1 && pageNum <= pagination.totalPages) {
              currentPage = pageNum;
              fetchThread(currentSignalId, currentPage);
            }
          });
          jumpInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              goBtn.click();
            }
          });
        }

        // Bind edit button events
        entriesContainer.querySelectorAll('.entry-edit-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            var entryEl = btn.closest('.entry');
            var content = entryEl.querySelector('.entry-content p').textContent;
            showEditModal(entryId, content);
          });
        });

        // Bind delete button events
        entriesContainer.querySelectorAll('.entry-delete-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            showDeleteConfirm(entryId);
          });
        });

        // Bind quote button events
        entriesContainer.querySelectorAll('.entry-quote-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryEl = btn.closest('.entry');
            var alias = btn.dataset.alias;
            var content = entryEl.querySelector('.entry-content p').textContent;
            quoteEntry(alias, content);
          });
        });

        // Bind report button events
        entriesContainer.querySelectorAll('.entry-report-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var entryId = btn.dataset.entryId;
            showReportModal(entryId);
          });
        });

        // Bind reaction button events
        entriesContainer.querySelectorAll('.reaction-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var reactionsEl = btn.closest('.entry-reactions');
            var entryId = reactionsEl.dataset.entryId;
            var reactionType = btn.dataset.reaction;
            toggleReaction(entryId, reactionType, btn);
          });
        });

        // Initialize avatars - uses avatar_config from entry data attribute
        AvatarRenderer.initAvatars({
          selector: '.avatar-mini',
          configSource: function(canvas) {
            var entryEl = canvas.closest('.entry');
            if (!entryEl) return AvatarRenderer.loadFromStorage();
            
            // Try to get avatar_config from data attribute (from backend)
            var configAttr = entryEl.getAttribute('data-avatar-config');
            if (configAttr) {
              try {
                return JSON.parse(configAttr);
              } catch (e) {}
            }
            
            // Fall back to localStorage
            return AvatarRenderer.loadFromStorage();
          }
        });
      }

      // Edit modal
      function showEditModal(entryId, currentContent) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="edit-modal">
            <div class="edit-modal-title">EDIT ENTRY</div>
            <textarea class="edit-modal-textarea">${currentContent}</textarea>
            <div class="edit-modal-actions">
              <button class="cancel-btn" id="edit-cancel">CANCEL</button>
              <button class="reply-submit" id="edit-save">SAVE</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var textarea = overlay.querySelector('.edit-modal-textarea');
        var cancelBtn = overlay.querySelector('#edit-cancel');
        var saveBtn = overlay.querySelector('#edit-save');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        saveBtn.addEventListener('click', function() {
          var newContent = textarea.value.trim();
          if (!newContent) return;

          saveBtn.disabled = true;
          saveBtn.textContent = 'SAVING...';

          AuthState.apiRequest('/api/entries/' + entryId, {
            method: 'PUT',
            body: JSON.stringify({ content: newContent })
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('ENTRY UPDATED', 'info');
              overlay.remove();
              fetchThread(currentSignalId, currentPage).then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
            } else {
              Notify.show(data.message || data.error || 'UPDATE FAILED', 'error');
              saveBtn.disabled = false;
              saveBtn.textContent = 'SAVE';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            saveBtn.disabled = false;
            saveBtn.textContent = 'SAVE';
          });
        });
      }

      // Delete confirmation
      function showDeleteConfirm(entryId) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="confirm-modal">
            <div class="confirm-modal-text">DELETE THIS ENTRY?</div>
            <div class="confirm-modal-actions">
              <button class="cancel-btn" id="delete-cancel">CANCEL</button>
              <button class="confirm-delete-btn" id="delete-confirm">DELETE</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var cancelBtn = overlay.querySelector('#delete-cancel');
        var confirmBtn = overlay.querySelector('#delete-confirm');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        confirmBtn.addEventListener('click', function() {
          confirmBtn.disabled = true;
          confirmBtn.textContent = 'DELETING...';

          AuthState.apiRequest('/api/entries/' + entryId, {
            method: 'DELETE'
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('ENTRY DELETED', 'info');
              overlay.remove();
              fetchThread(currentSignalId, currentPage).then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
            } else {
              Notify.show(data.error || 'DELETE FAILED', 'error');
              confirmBtn.disabled = false;
              confirmBtn.textContent = 'DELETE';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'DELETE';
          });
        });
      }

      // Quote entry - prefill reply textarea with structured quote format
      function quoteEntry(alias, content) {
        var replyTextarea = document.getElementById('reply-content');
        // Truncate quoted content if too long
        var quotedContent = content.length > 200 ? content.substring(0, 200) + '...' : content;
        var quotedText = '@' + alias + ' said:\n> ' + quotedContent.split('\n').join('\n> ') + '\n\n';
        replyTextarea.value = quotedText + replyTextarea.value;
        replyTextarea.focus();
        replyTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }

      // Markdown toolbar handlers
      document.querySelectorAll('.md-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var textarea = document.getElementById('reply-content');
          var start = textarea.selectionStart;
          var end = textarea.selectionEnd;
          var text = textarea.value;
          var selected = text.substring(start, end);
          var replacement = '';
          var cursorOffset = 0;
          
          switch(btn.dataset.md) {
            case 'bold':
              replacement = '**' + (selected || 'text') + '**';
              cursorOffset = selected ? 0 : -2;
              break;
            case 'italic':
              replacement = '*' + (selected || 'text') + '*';
              cursorOffset = selected ? 0 : -1;
              break;
            case 'strike':
              replacement = '~~' + (selected || 'text') + '~~';
              cursorOffset = selected ? 0 : -2;
              break;
            case 'code':
              if (selected.indexOf('\n') !== -1) {
                replacement = '```\n' + (selected || 'code') + '\n```';
              } else {
                replacement = '`' + (selected || 'code') + '`';
              }
              cursorOffset = selected ? 0 : -1;
              break;
            case 'link':
              replacement = '[' + (selected || 'text') + '](url)';
              cursorOffset = -1;
              break;
            case 'quote':
              replacement = '> ' + (selected || 'quote');
              break;
            case 'list':
              replacement = '- ' + (selected || 'item');
              break;
            case 'h1':
              replacement = '## ' + (selected || 'heading');
              break;
          }
          
          textarea.value = text.substring(0, start) + replacement + text.substring(end);
          textarea.focus();
          var newPos = start + replacement.length + cursorOffset;
          textarea.setSelectionRange(newPos, newPos);
        });
      });

      // Jump to first unread
      var jumpUnreadBtn = document.getElementById('jump-unread-btn');
      var firstUnreadId = null;

      function checkFirstUnread() {
        if (!currentSignalId) return;
        
        AuthState.apiRequest('/api/threads/' + currentSignalId + '/first-unread')
          .then(function(data) {
            if (data.success && data.hasUnread && data.firstUnreadId) {
              firstUnreadId = data.firstUnreadId;
              jumpUnreadBtn.classList.add('visible');
            } else {
              jumpUnreadBtn.classList.remove('visible');
            }
          })
          .catch(function() {});
      }

      jumpUnreadBtn.addEventListener('click', function() {
        if (firstUnreadId) {
          var entryEl = document.querySelector('[data-entry-id="' + firstUnreadId + '"]');
          if (entryEl) {
            entryEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            entryEl.classList.add('highlight-entry');
            setTimeout(function() { entryEl.classList.remove('highlight-entry'); }, 2000);
          }
        }
      });

      // Report modal
      function showReportModal(entryId) {
        var overlay = document.createElement('div');
        overlay.className = 'edit-modal-overlay';
        overlay.innerHTML = `
          <div class="report-modal">
            <div class="report-modal-title">REPORT ENTRY</div>
            <div class="report-reasons">
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="spam"> SPAM
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="harassment"> HARASSMENT
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="inappropriate"> INAPPROPRIATE CONTENT
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="misinformation"> MISINFORMATION
              </label>
              <label class="report-reason-option">
                <input type="radio" name="report-reason" value="other"> OTHER
              </label>
            </div>
            <textarea class="report-details-input" placeholder="Additional details (optional)..." rows="2" maxlength="500"></textarea>
            <div class="report-modal-actions">
              <button class="cancel-btn" id="report-cancel">CANCEL</button>
              <button class="report-submit-btn" id="report-submit">SUBMIT REPORT</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);

        var cancelBtn = overlay.querySelector('#report-cancel');
        var submitBtn = overlay.querySelector('#report-submit');
        var detailsInput = overlay.querySelector('.report-details-input');

        cancelBtn.addEventListener('click', function() {
          overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
          if (e.target === overlay) overlay.remove();
        });

        submitBtn.addEventListener('click', function() {
          var selectedReason = overlay.querySelector('input[name="report-reason"]:checked');
          if (!selectedReason) {
            Notify.show('SELECT A REASON', 'error');
            return;
          }

          submitBtn.disabled = true;
          submitBtn.textContent = 'SUBMITTING...';

          AuthState.apiRequest('/api/reports', {
            method: 'POST',
            body: JSON.stringify({
              entry_id: entryId,
              reason: selectedReason.value,
              details: detailsInput.value.trim()
            })
          })
          .then(function(data) {
            if (data.success) {
              Notify.show('REPORT SUBMITTED', 'info');
              overlay.remove();
            } else {
              Notify.show(data.error || 'REPORT FAILED', 'error');
              submitBtn.disabled = false;
              submitBtn.textContent = 'SUBMIT REPORT';
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
            submitBtn.disabled = false;
            submitBtn.textContent = 'SUBMIT REPORT';
          });
        });
      }

      // Toggle reaction on entry
      function toggleReaction(entryId, reactionType, btnEl) {
        btnEl.disabled = true;
        
        AuthState.apiRequest('/api/entries/' + entryId + '/react', {
          method: 'POST',
          body: JSON.stringify({ reaction_type: reactionType })
        })
        .then(function(data) {
          if (data.success) {
            var countEl = btnEl.querySelector('.reaction-count');
            var currentCount = parseInt(countEl.textContent) || 0;
            
            if (data.action === 'added') {
              countEl.textContent = currentCount + 1;
              btnEl.classList.add('reaction-active');
            } else {
              countEl.textContent = Math.max(0, currentCount - 1);
              btnEl.classList.remove('reaction-active');
            }
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'ERROR', 'error');
        })
        .finally(function() {
          btnEl.disabled = false;
        });
      }

      function applyFilters() {
        var filtered = allEntries.slice();
        
        // Search (client-side for current page)
        if (currentSearch) {
          var q = currentSearch.toLowerCase();
          filtered = filtered.filter(function(e) {
            return e.content.toLowerCase().indexOf(q) !== -1;
          });
        }
        
        // Sort
        if (currentSort === 'newest') {
          filtered.reverse();
        } else if (currentSort === 'oldest') {
          // default order is oldest first
        }
        
        renderEntries(filtered, allAvatarConfigs, currentPagination);
      }

      // Debounced search for better performance
      var debouncedSearch = Utils.debounce(function(value) {
        currentSearch = value;
        applyFilters();
      }, 200);
      
      searchInput.addEventListener('input', function() {
        debouncedSearch(this.value);
      });

      sortBtns.forEach(function(btn) {
        btn.addEventListener('click', function() {
          sortBtns.forEach(function(b) { b.classList.remove('active'); });
          btn.classList.add('active');
          currentSort = btn.dataset.sort;
          applyFilters();
        });
      });

      /**
       * Fetch thread data from API
       */
      function fetchThread(signalId, page) {
        page = page || 1;
        var url = '/api/thread/' + signalId + '?page=' + page;
        
        return AuthState.apiRequest(url)
          .then(function(data) {
            if (data.success && data.thread) {
              var params = new URLSearchParams(window.location.search);
              var roomId = data.thread.roomId || params.get('room') || 'room-001';
              var sigNum = signalId ? signalId.replace('sig-', '') : '000';
              data.thread.signalIndex = 'SIG.' + sigNum;
              data.thread.roomName = 'NODE.' + roomId.replace('room-', '');
              // Build avatarConfigs map from entries
              data.avatarConfigs = {};
              if (data.entries) {
                data.entries.forEach(function(entry) {
                  if (entry.avatarConfig) {
                    data.avatarConfigs[entry.id] = entry.avatarConfig;
                  }
                });
              }
            }
            return data;
          });
      }

      /**
       * Initialize page
       */
      function init() {
        var signalId = getSignalIdFromUrl();
        currentSignalId = signalId;

        if (!signalId) {
          threadTitleEl.textContent = 'SIGNAL NOT FOUND';
          renderEntries([], {}, null);
          return;
        }

        fetchThread(signalId, 1)
          .then(function(data) {
            if (data.success) {
              updateSignalMeta(data.thread);
              roomNameEl.textContent = data.thread.roomName || 'NODE.001';
              allEntries = data.entries || [];
              allAvatarConfigs = data.avatarConfigs || {};
              currentPagination = data.pagination || null;
              renderEntries(allEntries, allAvatarConfigs, currentPagination);
              
              // Check bookmark and subscription status
              checkBookmarkStatus(data.thread.id);
              checkSubscriptionStatus(data.thread.id);
              
              // Load poll if exists
              loadPoll(data.thread.id);
              
              // Check for first unread post
              checkFirstUnread();
              
              // Mark as read with last entry ID
              if (allEntries.length > 0) {
                var lastEntryId = allEntries[allEntries.length - 1].id;
                markThreadAsRead(data.thread.id, lastEntryId);
              }
            } else {
              threadTitleEl.textContent = 'ERROR: ' + (data.error || 'UNKNOWN');
              allEntries = [];
              allAvatarConfigs = {};
              currentPagination = null;
              renderEntries([], {}, null);
              Notify.show(data.error || 'FAILED TO LOAD SIGNAL', 'error');
            }
          })
          .catch(function(err) {
            threadTitleEl.textContent = 'CONNECTION ERROR';
            allEntries = [];
            allAvatarConfigs = {};
            currentPagination = null;
            renderEntries([], {}, null);
            Notify.show(err.message || 'CONNECTION ERROR', 'error');
          });
      }
      
      // Bookmark functionality
      var bookmarkBtn = document.getElementById('bookmark-btn');
      var currentThreadDbId = null;
      
      function checkBookmarkStatus(threadId) {
        currentThreadDbId = threadId;
        AuthState.apiRequest('/api/bookmarks/' + threadId + '/check')
          .then(function(data) {
            if (data.success && data.isBookmarked) {
              bookmarkBtn.textContent = '[SAVED]';
              bookmarkBtn.classList.add('bookmarked');
            } else {
              bookmarkBtn.textContent = '[SAVE]';
              bookmarkBtn.classList.remove('bookmarked');
            }
          });
      }
      
      bookmarkBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        bookmarkBtn.disabled = true;
        
        AuthState.apiRequest('/api/bookmarks/' + currentThreadDbId, { method: 'POST' })
          .then(function(data) {
            if (data.success) {
              if (data.action === 'added') {
                bookmarkBtn.textContent = '[SAVED]';
                bookmarkBtn.classList.add('bookmarked');
                Notify.show('THREAD SAVED', 'info');
              } else {
                bookmarkBtn.textContent = '[SAVE]';
                bookmarkBtn.classList.remove('bookmarked');
                Notify.show('BOOKMARK REMOVED', 'info');
              }
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
          })
          .finally(function() {
            bookmarkBtn.disabled = false;
          });
      });

      // Subscribe functionality
      var subscribeBtn = document.getElementById('subscribe-btn');
      var isSubscribed = false;

      function checkSubscriptionStatus(threadId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/subscribe')
          .then(function(data) {
            if (data.success) {
              isSubscribed = data.subscribed;
              updateSubscribeButton();
            }
          });
      }

      function updateSubscribeButton() {
        if (isSubscribed) {
          subscribeBtn.textContent = '[WATCHING]';
          subscribeBtn.classList.add('subscribed');
        } else {
          subscribeBtn.textContent = '[WATCH]';
          subscribeBtn.classList.remove('subscribed');
        }
      }

      subscribeBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        subscribeBtn.disabled = true;
        
        var method = isSubscribed ? 'DELETE' : 'POST';
        AuthState.apiRequest('/api/threads/' + currentThreadDbId + '/subscribe', { method: method })
          .then(function(data) {
            if (data.success) {
              isSubscribed = data.subscribed;
              updateSubscribeButton();
              Notify.show(isSubscribed ? 'SUBSCRIBED' : 'UNSUBSCRIBED', 'info');
            }
          })
          .catch(function(err) {
            Notify.show(err.message || 'ERROR', 'error');
          })
          .finally(function() {
            subscribeBtn.disabled = false;
          });
      });

      // Mark thread as read when viewing
      function markThreadAsRead(threadId, lastEntryId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/read', {
          method: 'POST',
          body: JSON.stringify({ last_entry_id: lastEntryId })
        });
      }

      // Poll functionality
      var pollContainer = document.getElementById('poll-container');
      var pollQuestion = document.getElementById('poll-question');
      var pollMeta = document.getElementById('poll-meta');
      var pollOptions = document.getElementById('poll-options');
      var pollVoteBtn = document.getElementById('poll-vote-btn');
      var pollTotal = document.getElementById('poll-total');
      var currentPoll = null;
      var selectedOptions = [];

      function loadPoll(threadId) {
        AuthState.apiRequest('/api/threads/' + threadId + '/poll')
          .then(function(data) {
            if (data.success && data.poll) {
              currentPoll = data.poll;
              renderPoll(data.poll);
            }
          });
      }

      function renderPoll(poll) {
        pollContainer.style.display = 'block';
        pollQuestion.textContent = poll.question;
        
        var metaText = 'Created by ' + poll.createdBy;
        var expiryClass = '';
        if (poll.endsAt) {
          var endsAt = new Date(poll.endsAt);
          var now = new Date();
          var hoursLeft = (endsAt - now) / (1000 * 60 * 60);
          
          if (poll.isExpired) {
            metaText += ' ‚Ä¢ <span class="poll-expiry expired">EXPIRED</span>';
          } else if (hoursLeft < 24) {
            metaText += ' ‚Ä¢ <span class="poll-expiry ending-soon">Ends in ' + Math.ceil(hoursLeft) + 'h</span>';
          } else {
            metaText += ' ‚Ä¢ Ends: ' + endsAt.toLocaleDateString();
          }
        }
        if (poll.allowMultiple) {
          metaText += ' ‚Ä¢ Multiple choice';
        }
        pollMeta.innerHTML = metaText;

        var hasVoted = poll.userVotes && poll.userVotes.length > 0;
        selectedOptions = poll.userVotes ? poll.userVotes.slice() : [];

        pollOptions.innerHTML = poll.options.map(function(opt) {
          var isSelected = selectedOptions.includes(opt.id);
          var votedClass = hasVoted || poll.isExpired ? 'voted' : '';
          var selectedClass = isSelected ? 'selected' : '';
          
          var barWidth = hasVoted || poll.isExpired ? opt.percentage : 0;
          
          return '<div class="poll-option-wrapper">' +
            '<div class="poll-option-bar" style="width: ' + barWidth + '%;"></div>' +
            '<label class="poll-option ' + votedClass + ' ' + selectedClass + '" data-option-id="' + opt.id + '">' +
              (hasVoted || poll.isExpired ? '' : '<input type="' + (poll.allowMultiple ? 'checkbox' : 'radio') + '" name="poll-option" value="' + opt.id + '" ' + (isSelected ? 'checked' : '') + '>') +
              '<span class="poll-option-text">' + escapeHtml(opt.text) + '</span>' +
              '<span class="poll-option-stats">' + opt.voteCount + ' (' + opt.percentage + '%)</span>' +
            '</label>' +
          '</div>';
        }).join('');

        pollTotal.textContent = poll.totalVoters + ' total voter' + (poll.totalVoters !== 1 ? 's' : '');

        // Show vote button if not voted and not expired
        if (!hasVoted && !poll.isExpired) {
          pollVoteBtn.style.display = 'inline-block';
          pollVoteBtn.disabled = true;

          // Bind option selection
          pollOptions.querySelectorAll('input').forEach(function(input) {
            input.addEventListener('change', function() {
              if (currentPoll.allowMultiple) {
                if (this.checked) {
                  selectedOptions.push(parseInt(this.value));
                } else {
                  selectedOptions = selectedOptions.filter(function(id) { return id !== parseInt(input.value); });
                }
              } else {
                selectedOptions = [parseInt(this.value)];
              }
              pollVoteBtn.disabled = selectedOptions.length === 0;
              
              // Update selected styling
              pollOptions.querySelectorAll('.poll-option').forEach(function(opt) {
                var optId = parseInt(opt.dataset.optionId);
                if (selectedOptions.includes(optId)) {
                  opt.classList.add('selected');
                } else {
                  opt.classList.remove('selected');
                }
              });
            });
          });
        } else {
          pollVoteBtn.style.display = 'none';
        }
      }

      function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      pollVoteBtn.addEventListener('click', function() {
        if (!currentPoll || selectedOptions.length === 0) return;
        pollVoteBtn.disabled = true;
        pollVoteBtn.textContent = 'VOTING...';

        AuthState.apiRequest('/api/polls/' + currentPoll.id + '/vote', {
          method: 'POST',
          body: JSON.stringify({ optionIds: selectedOptions })
        })
        .then(function(data) {
          if (data.success) {
            Notify.show('VOTE RECORDED', 'info');
            loadPoll(currentThreadDbId);
          } else {
            Notify.show(data.error || 'VOTE FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'VOTE ERROR', 'error');
        })
        .finally(function() {
          pollVoteBtn.textContent = 'VOTE';
          pollVoteBtn.disabled = false;
        });
      });

      // Reply form handler
      var replyForm = document.getElementById('reply-form');
      var replyContent = document.getElementById('reply-content');
      var draftIndicator = document.createElement('span');
      draftIndicator.className = 'draft-indicator';
      draftIndicator.textContent = 'Draft saved';
      draftIndicator.style.display = 'none';
      replyForm.querySelector('.reply-submit').parentNode.insertBefore(draftIndicator, replyForm.querySelector('.reply-submit'));
      
      // Initialize @mentions autocomplete
      Utils.initMentions(replyContent, AuthState.apiRequest);
      
      // Draft auto-save with debounce
      var draftKey = 'thread_' + getSignalIdFromUrl();
      var savedDraft = Utils.drafts.get(draftKey);
      if (savedDraft) {
        replyContent.value = savedDraft;
        draftIndicator.style.display = 'inline';
      }
      
      var saveDraft = Utils.debounce(function(content) {
        if (content.trim()) {
          Utils.drafts.set(draftKey, content);
          draftIndicator.style.display = 'inline';
          draftIndicator.classList.add('pulse');
          setTimeout(function() { draftIndicator.classList.remove('pulse'); }, 500);
        } else {
          Utils.drafts.remove(draftKey);
          draftIndicator.style.display = 'none';
        }
      }, 1000);
      
      replyContent.addEventListener('input', function() {
        saveDraft(this.value);
      });
      
      replyForm.addEventListener('submit', function(e) {
        e.preventDefault();
        var content = replyContent.value.trim();
        if (!content) return;
        
        var submitBtn = replyForm.querySelector('.reply-submit');
        submitBtn.disabled = true;
        submitBtn.textContent = 'TRANSMITTING...';
        
        AuthState.apiRequest('/api/entries', {
          method: 'POST',
          body: JSON.stringify({
            threadId: parseInt(currentSignalId),
            content: content
          })
        })
        .then(function(data) {
          if (data.success) {
            replyContent.value = '';
            Utils.drafts.remove(draftKey);
            draftIndicator.style.display = 'none';
            Notify.show('ENTRY RECORDED', 'info');
            // Reload entries
            fetchThread(currentSignalId, currentPage)
              .then(function(data) {
                if (data.success) {
                  allEntries = data.entries || [];
                  allAvatarConfigs = data.avatarConfigs || {};
                  currentPagination = data.pagination || null;
                  renderEntries(allEntries, allAvatarConfigs, currentPagination);
                }
              });
          } else {
            Notify.show(data.error || 'TRANSMISSION FAILED', 'error');
          }
        })
        .catch(function(err) {
          Notify.show(err.message || 'CONNECTION ERROR', 'error');
        })
        .finally(function() {
          submitBtn.disabled = false;
          submitBtn.textContent = 'TRANSMIT';
        });
      });

      // Admin controls for pin/lock
      var pinBtn = document.getElementById('pin-btn');
      var lockBtn = document.getElementById('lock-btn');

      pinBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        pinBtn.disabled = true;
        
        AuthState.apiRequest('/api/admin/threads/' + currentThreadDbId + '/pin', { method: 'PUT' })
          .then(function(data) {
            if (data.success) {
              currentThreadData.isPinned = data.is_pinned;
              updateThreadBadges(currentThreadData);
              updateAdminControls(currentThreadData);
              Notify.show(data.is_pinned ? 'THREAD PINNED' : 'THREAD UNPINNED', 'info');
            }
          })
          .catch(function(err) {
            Notify.show('ERROR', 'error');
          })
          .finally(function() {
            pinBtn.disabled = false;
          });
      });

      lockBtn.addEventListener('click', function() {
        if (!currentThreadDbId) return;
        lockBtn.disabled = true;
        
        AuthState.apiRequest('/api/admin/threads/' + currentThreadDbId + '/lock', { method: 'PUT' })
          .then(function(data) {
            if (data.success) {
              currentThreadData.isLocked = data.is_locked;
              updateThreadBadges(currentThreadData);
              updateAdminControls(currentThreadData);
              Notify.show(data.is_locked ? 'THREAD LOCKED' : 'THREAD UNLOCKED', 'info');
              // Update reply form visibility
              updateReplyFormForLock(data.is_locked);
            }
          })
          .catch(function(err) {
            Notify.show('ERROR', 'error');
          })
          .finally(function() {
            lockBtn.disabled = false;
          });
      });

      function updateReplyFormForLock(isLocked) {
        var replyFormContainer = document.querySelector('.reply-form-container');
        if (isLocked && !AuthState.isAdmin()) {
          replyFormContainer.innerHTML = '<div class="locked-notice">üîí THIS THREAD IS LOCKED</div>';
        }
      }

      // Back to top button
      var backToTopBtn = document.getElementById('back-to-top');
      
      window.addEventListener('scroll', function() {
        if (window.scrollY > 300) {
          backToTopBtn.classList.add('visible');
        } else {
          backToTopBtn.classList.remove('visible');
        }
      });
      
      backToTopBtn.addEventListener('click', function() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      // ===== WebSocket Real-time Updates =====
      var wsConnectionStatus = document.querySelector('[data-bind="connection-status"]');
      var wsSubscribedThread = null;

      function initWebSocket() {
        if (typeof WSManager === 'undefined') return;

        // Update connection status indicator
        WSManager.on('connected', function() {
          if (wsConnectionStatus) wsConnectionStatus.textContent = 'CONN.LIVE';
          wsConnectionStatus.classList.add('ws-connected');
          // Subscribe to current thread
          if (currentSignalId) {
            wsSubscribedThread = currentSignalId;
            WSManager.subscribeThread(currentSignalId);
          }
        });

        WSManager.on('disconnected', function() {
          if (wsConnectionStatus) wsConnectionStatus.textContent = 'CONN.OFFLINE';
          wsConnectionStatus.classList.remove('ws-connected');
        });

        // Handle new entry in real-time
        WSManager.on('new_entry', function(entry) {
          // Don't add if we already have it
          if (allEntries.some(function(e) { return e.id === entry.id; })) return;
          
          // Add to entries array
          allEntries.push(entry);
          
          // Create and append new entry element
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = UIComponents.entryElement(entry, currentUserId);
          var newEntryEl = tempDiv.firstElementChild;
          
          // Add highlight animation class
          newEntryEl.classList.add('entry-new');
          
          // Insert before empty state or at end
          var emptyState = entriesContainer.querySelector('.empty-state');
          if (emptyState) {
            entriesContainer.removeChild(emptyState);
          }
          entriesContainer.appendChild(newEntryEl);
          
          // Bind events for new entry
          bindEntryEvents(newEntryEl);
          
          // Initialize avatar
          var canvas = newEntryEl.querySelector('.avatar-mini');
          if (canvas) {
            var configAttr = newEntryEl.getAttribute('data-avatar-config');
            if (configAttr) {
              try {
                AvatarRenderer.render(canvas, JSON.parse(configAttr));
              } catch (e) {}
            }
          }
          
          // Update entry count
          entryCountEl.textContent = allEntries.length;
          
          // Show notification if not at bottom
          var isAtBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100;
          if (!isAtBottom) {
            Notify.show('NEW ENTRY RECEIVED', 'info');
          }
        });

        // Handle entry edit in real-time
        WSManager.on('entry_edited', function(data) {
          var entryEl = document.querySelector('.entry[data-entry-id="' + data.entryId + '"]');
          if (entryEl) {
            var contentEl = entryEl.querySelector('.entry-content p');
            if (contentEl) {
              contentEl.innerHTML = data.content;
            }
            // Update edited indicator
            var metaEl = entryEl.querySelector('.entry-meta');
            if (metaEl && !metaEl.querySelector('.entry-edited')) {
              metaEl.insertAdjacentHTML('beforeend', '<span class="entry-edited">(edited)</span>');
            }
            // Flash highlight
            entryEl.classList.add('entry-updated');
            setTimeout(function() { entryEl.classList.remove('entry-updated'); }, 2000);
          }
          // Update in allEntries array
          allEntries.forEach(function(e) {
            if (e.id === data.entryId) {
              e.content = data.content;
            }
          });
        });

        // Handle entry delete in real-time
        WSManager.on('entry_deleted', function(data) {
          var entryEl = document.querySelector('.entry[data-entry-id="' + data.entryId + '"]');
          if (entryEl) {
            entryEl.classList.add('entry-deleted');
            setTimeout(function() {
              entryEl.remove();
            }, 500);
          }
          // Remove from allEntries array
          allEntries = allEntries.filter(function(e) { return e.id !== data.entryId; });
          entryCountEl.textContent = allEntries.length;
        });
      }

      // Helper function to bind events on dynamically added entries
      function bindEntryEvents(entryEl) {
        // Edit button
        var editBtn = entryEl.querySelector('.entry-edit-btn');
        if (editBtn) {
          editBtn.addEventListener('click', function() {
            var entryId = editBtn.dataset.entryId;
            var content = entryEl.querySelector('.entry-content p').textContent;
            showEditModal(entryId, content);
          });
        }
        
        // Delete button
        var deleteBtn = entryEl.querySelector('.entry-delete-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', function() {
            var entryId = deleteBtn.dataset.entryId;
            showDeleteConfirm(entryId);
          });
        }
        
        // Quote button
        var quoteBtn = entryEl.querySelector('.entry-quote-btn');
        if (quoteBtn) {
          quoteBtn.addEventListener('click', function() {
            var alias = quoteBtn.dataset.alias;
            var content = entryEl.querySelector('.entry-content p').textContent;
            quoteEntry(alias, content);
          });
        }
        
        // Report button
        var reportBtn = entryEl.querySelector('.entry-report-btn');
        if (reportBtn) {
          reportBtn.addEventListener('click', function() {
            var entryId = reportBtn.dataset.entryId;
            showReportModal(entryId);
          });
        }
        
        // Reaction buttons
        entryEl.querySelectorAll('.reaction-btn').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var reactionsEl = btn.closest('.entry-reactions');
            var entryId = reactionsEl.dataset.entryId;
            var reactionType = btn.dataset.reaction;
            toggleReaction(entryId, reactionType, btn);
          });
        });
      }

      // Initialize WebSocket connection
      initWebSocket();

      // Keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // 'r' - Focus reply textarea
        if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          replyContent.focus();
        }
        
        // 'g' then 't' - Go to top
        if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // 'g' then 'b' - Go to bottom
        if (e.key === 'b' && !e.ctrlKey && !e.metaKey) {
          window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
        
        // 'j' - Scroll down
        if (e.key === 'j' && !e.ctrlKey && !e.metaKey) {
          window.scrollBy({ top: 100, behavior: 'smooth' });
        }
        
        // 'k' - Scroll up
        if (e.key === 'k' && !e.ctrlKey && !e.metaKey) {
          window.scrollBy({ top: -100, behavior: 'smooth' });
        }
        
        // '[' - Previous page
        if (e.key === '[' && currentPagination && currentPage > 1) {
          currentPage--;
          fetchThread(currentSignalId, currentPage);
        }
        
        // ']' - Next page
        if (e.key === ']' && currentPagination && currentPage < currentPagination.totalPages) {
          currentPage++;
          fetchThread(currentSignalId, currentPage);
        }
        
        // '?' - Show keyboard shortcuts modal
        if (e.key === '?' && e.shiftKey) {
          e.preventDefault();
          shortcutsOverlay.classList.add('active');
        }
        
        // Escape - Close shortcuts modal
        if (e.key === 'Escape') {
          shortcutsOverlay.classList.remove('active');
        }
      });
      
      // Theme toggle initialization
      function initTheme() {
        var themeToggle = document.getElementById('theme-toggle');
        var savedTheme = Utils.storage.get('forum_theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        themeToggle.setAttribute('aria-pressed', savedTheme === 'light');
        themeToggle.setAttribute('aria-label', savedTheme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode');
        themeToggle.innerHTML = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        
        themeToggle.addEventListener('click', function() {
          var currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
          var newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          document.documentElement.setAttribute('data-theme', newTheme);
          Utils.storage.set('forum_theme', newTheme);
          themeToggle.setAttribute('aria-pressed', newTheme === 'light');
          themeToggle.setAttribute('aria-label', newTheme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode');
          themeToggle.innerHTML = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
          Notify.show('THEME: ' + newTheme.toUpperCase(), 'info');
        });
      }
      
      // Keyboard shortcuts modal
      var shortcutsOverlay = document.getElementById('shortcuts-modal');
      var shortcutsClose = shortcutsOverlay.querySelector('.shortcuts-close');
      
      shortcutsClose.addEventListener('click', function() {
        shortcutsOverlay.classList.remove('active');
      });
      
      shortcutsOverlay.addEventListener('click', function(e) {
        if (e.target === shortcutsOverlay) {
          shortcutsOverlay.classList.remove('active');
        }
      });
      
      // Scroll progress bar
      var scrollProgress = document.getElementById('scroll-progress');
      var updateScrollProgress = Utils.throttle(function() {
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        var docHeight = document.documentElement.scrollHeight - window.innerHeight;
        var progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
        scrollProgress.style.width = progress + '%';
      }, 16);
      
      window.addEventListener('scroll', updateScrollProgress, { passive: true });
      
      // Initialize theme on load
      initTheme();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      document.querySelector('[data-action="logout"]').addEventListener('click', function(e) {
        e.preventDefault();
        AuthState.logout();
      });
    })();
  </script>

</body>
</html>